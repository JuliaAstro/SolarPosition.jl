var documenterSearchIndex = {"docs":
[{"location":"examples/plotting/#plotting-examples","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"","category":"section"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"SolarPosition.jl provides a plotting extension based on Makie.jl.","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"To use it, simply import both the SolarPosition and Makie packages:","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"using SolarPosition\nusing CairoMakie\n\n# supporting packages\nusing Dates\nusing TimeZones\nusing DataFrames\n\nplotsDir = joinpath(dirname(pathof(SolarPosition)), \"..\", \"docs\", \"build\", \"plots\")\nmkpath(plotsDir)","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"This example notebook is based on the pvlib sun path example.","category":"page"},{"location":"examples/plotting/#Basic-Sun-Path-Plotting","page":"Using the Makie.jl plotting extension","title":"Basic Sun Path Plotting","text":"","category":"section"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"Let's start by defining an observer location and calculating solar positions for a whole year:","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"# Define observer location (New Delhi, India)\n# Parameters: latitude, longitude, altitude in meters\ntz = tz\"Asia/Kolkata\"\nobs = Observer(28.6, 77.2, 0.0)\n\n# Generate hourly timestamps for a whole year\ntimes = ZonedDateTime(DateTime(2019), tz):Hour(1):ZonedDateTime(DateTime(2020), tz)\n\n# This returns a NamedTuple of Vectors\npositions = solar_position(obs, times)\n\n# We can inspect the first few entries by converting to a DataFrame\nfirst(DataFrame(positions), 5)","category":"page"},{"location":"examples/plotting/#Simple-Sun-Path-Plot-in-Cartesian-Coordinates","page":"Using the Makie.jl plotting extension","title":"Simple Sun Path Plot in Cartesian Coordinates","text":"","category":"section"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"We can visualize solar positions in cartesian coordinates using the sunpathplot function:","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"fig = Figure(backgroundcolor = (:white, 0.0), textcolor= \"#f5ab35\")\nax = Axis(fig[1, 1], backgroundcolor = (:white, 0.0))\nsunpathplot!(ax, positions, hour_labels = false)\nfig","category":"page"},{"location":"examples/plotting/#Polar-Coordinates-with-Hour-Labels","page":"Using the Makie.jl plotting extension","title":"Polar Coordinates with Hour Labels","text":"","category":"section"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"We can also work directly with a DataFrame.","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"Plotting in polar coordinates with sunpathpolarplot may yield a more intuitive representation of the solar path. Here, we also enable hourly labels for better readability:","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"df = DataFrame(positions)\nfig2 = Figure(backgroundcolor = :transparent, textcolor= \"#f5ab35\", size = (800, 600))\nax2 = PolarAxis(fig2[1, 1], backgroundcolor = \"#1f2424\")\n# ax2 = PolarAxis(fig2[1, 1], backgroundcolor = (:white, 0.0))\nsunpathpolarplot!(ax2, df, hour_labels = true)\n\n# Draw individual days\nline_objects = []\nfor (date, label) in [(Date(\"2019-03-21\"), \"Mar 21\"),\n                      (Date(\"2019-06-21\"), \"Jun 21\"),\n                      (Date(\"2019-12-21\"), \"Dec 21\")]\n    times = ZonedDateTime(DateTime(date), tz):Minute(5):ZonedDateTime(DateTime(date) + Day(1), tz)\n    solpos = solar_position(obs, times)\n    above_horizon = solpos.elevation .> 0\n    day_df = DataFrame(solpos)\n    day_filtered = day_df[above_horizon, :]\n    line_obj = lines!(ax2, deg2rad.(day_filtered.azimuth), day_filtered.zenith,\n                      linewidth = 2, label = label)\n    push!(line_objects, line_obj)\nend\n\n# Add legend below the plot\nfig2[2, 1] = Legend(fig2, line_objects, [\"Mar 21\", \"Jun 21\", \"Dec 21\"],\n                    orientation = :horizontal, tellheight = true, backgroundcolor = :transparent)\nfig2\n\nsave(joinpath(plotsDir,\"sunpathpolarplot.png\"), fig2)","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"The figure-8 patterns are known as analemmas, which represent the sun's position at the same time of day throughout the year.","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"Note that in polar coordinates, the radial distance from the center represents the zenith angle (90° - elevation). Thus, points closer to the center indicate higher elevations. Conversely, a zenith angle of more than 90° (negative elevation) indicates that the sun is below the horizon. Tracing a path from right to left corresponds to the sun's movement from east to west.","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"It tells us when the sun rises, reaches its highest point, and sets. And hence also the length of the day. From the figure we can also read that in June the days are longest, while in December they are shortest.","category":"page"},{"location":"examples/plotting/#Plotting-without-a-custom-axis","page":"Using the Makie.jl plotting extension","title":"Plotting without a custom axis","text":"","category":"section"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"Finally, we can also create plots without explicitly defining an axis beforehand. This is a more concise way to create plots, but it offers less customization:","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"sunpathpolarplot(df, hour_labels = true, colorbar = true)","category":"page"},{"location":"contributing/#contributing","page":"Contributing guidelines","title":"Contributing guidelines","text":"","category":"section"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"First of all, thanks for the interest!","category":"page"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"We welcome all kinds of contribution, including, but not limited to code, documentation, examples, configuration, issue creating, etc.","category":"page"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"Be polite and respectful.","category":"page"},{"location":"contributing/#Bug-reports-and-discussions","page":"Contributing guidelines","title":"Bug reports and discussions","text":"","category":"section"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"If you think you found a bug, feel free to open an issue. Focused suggestions and requests can also be opened as issues. Before opening a pull request, start an issue or a discussion on the topic, please.","category":"page"},{"location":"contributing/#Working-on-an-issue","page":"Contributing guidelines","title":"Working on an issue","text":"","category":"section"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"If you found an issue that interests you, comment on that issue what your plans are. If the solution to the issue is clear, you can immediately create a pull request (see below). Otherwise, say what your proposed solution is and wait for a discussion around it.","category":"page"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"tip: Tip\n","category":"page"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"Feel free to ping us after a few days if there are no responses.","category":"page"},{"location":"reference/#reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"reference/#Contents","page":"API reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"API reference","title":"API reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"API reference","title":"API reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#SolarPosition.Positioning","page":"API reference","title":"SolarPosition.Positioning","text":"Collection of solar positioning algorithms.\n\n\n\n\n\n","category":"module"},{"location":"reference/#SolarPosition.Positioning.Observer","page":"API reference","title":"SolarPosition.Positioning.Observer","text":"Observer{T}\n\nObserver location (degrees, meters). Use Float64 for speed unless you need higher precision.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SolarPosition.Positioning.SolarPos","page":"API reference","title":"SolarPosition.Positioning.SolarPos","text":"SolarPos{T}\n\nDescribes a single solar position.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SolarPosition.Positioning._solar_position-Union{Tuple{T}, Tuple{Observer{T}, Dates.DateTime, PSA}} where T","page":"API reference","title":"SolarPosition.Positioning._solar_position","text":"_solar_position(\n    obs::Observer{T},\n    dt::DateTime,\n    ::PSA,\n) -> SolarPos{T}\n\nPSA algorithm implementation stub.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SolarPosition.Positioning._solar_position-Union{Tuple{T}, Tuple{Observer{T}, TimeZones.ZonedDateTime, SolarPosition.Positioning.NOAA}} where T","page":"API reference","title":"SolarPosition.Positioning._solar_position","text":"_solar_position(\n    obs::Observer{T},\n    dt::ZonedDateTime,\n    ::NOAA,\n) -> SolarPos{T}\n\nNOAA algorithm implementation stub.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SolarPosition.Positioning.solar_position","page":"API reference","title":"SolarPosition.Positioning.solar_position","text":"solar_position(obs::Observer, dt::DateTime; alg::SolarAlgorithm=PSA(), kwargs...) -> SolarPos\nsolar_position(obs::Observer, dt::ZonedDateTime; alg::SolarAlgorithm=PSA(), kwargs...) -> SolarPos\nsolar_position(latitude::T, longitude::T, altitude::T, dt::DateTime;\n               alg::SolarAlgorithm=PSA(), kwargs...) -> SolarPos where {T<:AbstractFloat}\nsolar_position(latitude::T, longitude::T, altitude::T, dt::ZonedDateTime;\n               alg::SolarAlgorithm=PSA(), kwargs...) -> SolarPos where {T<:AbstractFloat}\nsolar_position(latitude::AbstractFloat, longitude::AbstractFloat, dt::DateTime;\n               alg::SolarAlgorithm=PSA(), kwargs...) -> SolarPos\nsolar_position(latitude::AbstractFloat, longitude::AbstractFloat, dt::ZonedDateTime;\n               alg::SolarAlgorithm=PSA(), kwargs...) -> SolarPos\nsolar_position(dt::DateTime; latitude::AbstractFloat, longitude::AbstractFloat,\n               altitude::AbstractFloat=0.0, alg::SolarAlgorithm=PSA(), kwargs...) -> SolarPos\nsolar_position(dt::ZonedDateTime; latitude::AbstractFloat, longitude::AbstractFloat,\n               altitude::AbstractFloat=0.0, alg::SolarAlgorithm=PSA(), kwargs...) -> SolarPos\nsolar_position(obs::Observer, dts::AbstractVector{DateTime};\n               alg::SolarAlgorithm=PSA(), kwargs...) -> NamedTuple\nsolar_position(obs::Observer, dts::AbstractVector{ZonedDateTime};\n               alg::SolarAlgorithm=PSA(), kwargs...) -> NamedTuple\nsolar_position(obs::Observer, dts::AbstractRange{DateTime};\n               alg::SolarAlgorithm=PSA(), kwargs...) -> NamedTuple\nsolar_position(obs::Observer, dts::AbstractRange{ZonedDateTime};\n               alg::SolarAlgorithm=PSA(), kwargs...) -> NamedTuple\nsolar_position(dts::AbstractVector{DateTime}; latitude::AbstractFloat, longitude::AbstractFloat,\n               altitude::AbstractFloat=0.0, alg::SolarAlgorithm=PSA(), kwargs...) -> NamedTuple\nsolar_position(dts::AbstractVector{ZonedDateTime}; latitude::AbstractFloat, longitude::AbstractFloat,\n               altitude::AbstractFloat=0.0, alg::SolarAlgorithm=PSA(), kwargs...) -> NamedTuple\nsolar_position(dts::AbstractRange{DateTime}; latitude::AbstractFloat, longitude::AbstractFloat,\n               altitude::AbstractFloat=0.0, alg::SolarAlgorithm=PSA(), kwargs...) -> NamedTuple\nsolar_position(dts::AbstractRange{ZonedDateTime}; latitude::AbstractFloat, longitude::AbstractFloat,\n               altitude::AbstractFloat=0.0, alg::SolarAlgorithm=PSA(), kwargs...) -> NamedTuple\n\nCompute the apparent solar position for a given observer at time dt or vector of times dts.\n\nArguments\n\nobs::Observer : Observer location (latitude, longitude, altitude).\nlatitude, longitude, altitude : Specify observer location directly.\ndt::DateTime or ZonedDateTime : Time at which to compute solar position.\ndts::AbstractVector{DateTime} or AbstractVector{ZonedDateTime} : Vector of times for batch computation.\nalg::SolarAlgorithm : Algorithm to use (default: PSA()).\nkwargs... : Additional keyword arguments forwarded to the algorithm.\n\nReturns\n\nSolarPos : Struct containing solar zenith, azimuth, elevation (for single time).\nNamedTuple : Named tuple with datetime, azimuth, elevation, zenith vectors (for multiple times).\n\nNotes\n\nAll angles are in radians.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SolarPosition.Positioning.solar_position!-Tuple{Any, Observer}","page":"API reference","title":"SolarPosition.Positioning.solar_position!","text":"solar_position!(table, obs::Observer; dt_col::Symbol=:datetime, alg::SolarAlgorithm=PSA(), kwargs...)\nsolar_position!(table; latitude::AbstractFloat, longitude::AbstractFloat,\n                altitude::AbstractFloat=0.0, alg::SolarAlgorithm=PSA(), kwargs...)\n\nCompute solar positions for all times in a table and add the results as new columns.\n\nArguments\n\ntable : Table-like object with datetime column (must support Tables.jl interface).\nobs::Observer : Observer location (latitude, longitude, altitude).\nlatitude, longitude, altitude : Specify observer location directly.\ndt_col::Symbol : Name of the datetime column (default: :datetime).\nalg::SolarAlgorithm : Algorithm to use (default: PSA()).\nkwargs... : Additional keyword arguments forwarded to the algorithm.\n\nReturns\n\nModified table with added columns: azimuth, elevation, zenith.\n\nNotes\n\nAll angles are in radians. The input table is modified in-place by adding new columns.\n\n\n\n\n\n","category":"method"},{"location":"#SolarPosition.jl","page":"SolarPosition.jl","title":"SolarPosition.jl","text":"","category":"section"},{"location":"","page":"SolarPosition.jl","title":"SolarPosition.jl","text":"SolarPosition.jl provides a simple, unified interface to a collection of solar position algorithms written in pure, performant julia. The position of the sun in the sky is based on date, time, and a given observer location.","category":"page"},{"location":"","page":"SolarPosition.jl","title":"SolarPosition.jl","text":"A solar position algorithm is commonly used to calculate the solar zenith and azimuth angles, which are essential for various applications such as solar energy systems, building design, and climate studies.","category":"page"},{"location":"#Solar-positioning-algorithms","page":"SolarPosition.jl","title":"Solar positioning algorithms","text":"","category":"section"},{"location":"","page":"SolarPosition.jl","title":"SolarPosition.jl","text":"Here we provide an overview of the solar positioning algorithms currently implemented in SolarPosition.jl. Each algorithm is described with its reference paper, claimed accuracy and implementation status.","category":"page"},{"location":"","page":"SolarPosition.jl","title":"SolarPosition.jl","text":"Algorithm Reference Accuracy Status\nPSA Blanco-Muriel et al. ±0.0083° ✅\nNOAA Global Monitoring Laboratory ±0.0167° ❌","category":"page"},{"location":"examples/basic/#basic-example","page":"Basic Example","title":"Basic Example","text":"","category":"section"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"This section demonstrates basic usage of SolarPosition.jl for calculating solar positions.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"First, we need to import the package along with some supporting packages. Although not strictly necessary, it is common to work with time zone-aware datetimes using the TimeZones.jl package.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"using SolarPosition\n\n# supporting packages\nusing Dates\nusing DataFrames\nusing TimeZones","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"We can define an observer location using the Observer struct, which takes latitude, longitude, and altitude (in meters) as arguments.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"obs = Observer(37.7749, -122.4194, 100.0)  # San Francisco","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"Finally, we can calculate the solar position for a specific date and time using the solar_position function. The time should be provided as a ZonedDateTime to ensure correct handling of time zones.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"tz = tz\"America/Los_Angeles\"\nzdt = ZonedDateTime(2023, 6, 21, 12, 0, 0, tz)  # Summer solstice noon\nposition = solar_position(obs, zdt)\n\nprintln(\"Solar position at summer solstice noon in San Francisco:\")\nprintln(\"Azimuth: $(round(position.azimuth, digits=2))°\")\nprintln(\"Elevation: $(round(position.elevation, digits=2))°\")","category":"page"},{"location":"examples/basic/#Using-DateTime-in-UTC","page":"Basic Example","title":"Using DateTime in UTC","text":"","category":"section"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"Alternatively, we can directly pass a DateTime (assumed to be in UTC)","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"zdt_utc = DateTime(zdt, UTC)\nposition_utc = solar_position(obs, zdt_utc)\nprintln(\"Azimuth (UTC): $(round(position_utc.azimuth, digits=2))°\")\nprintln(\"Elevation (UTC): $(round(position_utc.elevation, digits=2))°\")","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"It is also possible to calculate solar positions for multiple timestamps at once by passing a vector or range of ZonedDateTime or DateTime objects.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"# Generate hourly timestamps for a whole year\ntimes = ZonedDateTime(DateTime(2019), tz):Hour(1):ZonedDateTime(DateTime(2020), tz)\n\n# This returns a NamedTuple of Vectors\npositions = solar_position(obs, times)\n\n# We can inspect the first few entries by converting to a DataFrame\nfirst(DataFrame(positions), 5)","category":"page"},{"location":"examples/basic/#Passing-Latitude-and-Longitude-as-keyword-arguments","page":"Basic Example","title":"Passing Latitude and Longitude as keyword arguments","text":"","category":"section"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"Lastly, we show that we can pass latitude and longitude directly without creating an Observer object. In this case the library will create an Observer object for us.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"times = DateTime(2019):Hour(1):DateTime(2020)\nposition_direct = solar_position(times; latitude=37.7749, longitude=-122.4194, altitude=100.0)\nfirst(DataFrame(position_direct), 5)","category":"page"}]
}
