var documenterSearchIndex = {"docs":
[{"location":"refraction/#refraction-algorithms","page":"Refraction Algorithms","title":"Refraction Algorithms","text":"","category":"section"},{"location":"refraction/","page":"Refraction Algorithms","title":"Refraction Algorithms","text":"Atmospheric refraction correction algorithms available in SolarPosition.jl.","category":"page"},{"location":"refraction/","page":"Refraction Algorithms","title":"Refraction Algorithms","text":"Atmospheric refraction causes the apparent position of the sun to differ from its true geometric position. This effect is most pronounced near the horizon and can be corrected using various atmospheric models.","category":"page"},{"location":"refraction/","page":"Refraction Algorithms","title":"Refraction Algorithms","text":"Algorithm Reference Atmospheric Parameters Status\nHughes [Hug85] Pressure, Temperature ✅","category":"page"},{"location":"refraction/","page":"Refraction Algorithms","title":"Refraction Algorithms","text":"To calculate refraction, we can use the refraction function:","category":"page"},{"location":"refraction/#SolarPosition.Refraction.refraction","page":"Refraction Algorithms","title":"SolarPosition.Refraction.refraction","text":"refraction(model::RefractionAlgorithm, elevation::T) where {T<:AbstractFloat}\n\nApply atmospheric refraction correction to the given elevation angle(s).\n\nArguments\n\nmodel::RefractionAlgorithm: Refraction model to use (e.g., HUGHES())\nelevation::T: True (unrefracted) solar elevation angle in degrees\n\nReturns\n\nRefraction correction in degrees to be added to the elevation angle\n\nExamples\n\nusing SolarPosition\nhughes = HUGHES(101325.0, 15.0)  # 15°C temperature\nelevation = 30.0  # 30 degrees\ncorrection = refraction(hughes, elevation)\napparent_elevation = elevation + correction\n\n\n\n\n\n","category":"function"},{"location":"refraction/","page":"Refraction Algorithms","title":"Refraction Algorithms","text":"This function is typically used internally by the solar_position function when a refraction algorithm is specified, but is also a publicly available method.","category":"page"},{"location":"refraction/","page":"Refraction Algorithms","title":"Refraction Algorithms","text":"When using NoRefraction() (the default), the solar_position function returns a SolPos struct containing only the true geometric angles (azimuth, elevation, zenith). In this case, no refraction correction is applied.","category":"page"},{"location":"refraction/#SolarPosition.Refraction.NoRefraction","page":"Refraction Algorithms","title":"SolarPosition.Refraction.NoRefraction","text":"NoRefraction <: RefractionAlgorithm\n\nIndicates that no atmospheric refraction correction should be applied.\n\nThis is the default refraction setting for solar position calculations. When used, only basic solar position (azimuth, elevation, zenith) is computed.\n\n\n\n\n\n","category":"type"},{"location":"refraction/#hughes-refraction","page":"Refraction Algorithms","title":"Hughes","text":"","category":"section"},{"location":"refraction/","page":"Refraction Algorithms","title":"Refraction Algorithms","text":"The Hughes refraction model accounts for atmospheric pressure and temperature effects.","category":"page"},{"location":"refraction/","page":"Refraction Algorithms","title":"Refraction Algorithms","text":"This model was developed by [Hug85] and is used in the SUNAEP software [Zim81]. It's also the basis for the refraction correction in NOAA's solar position calculator (using fixed pressure of 101325 Pa and temperature of 10°C).","category":"page"},{"location":"refraction/","page":"Refraction Algorithms","title":"Refraction Algorithms","text":"When using a refraction algorithm like Hughes(), the solar_position function returns an ApparentSolPos struct containing both true and apparent angles.","category":"page"},{"location":"refraction/#SolarPosition.Refraction.HUGHES","page":"Refraction Algorithms","title":"SolarPosition.Refraction.HUGHES","text":"struct HUGHES{T} <: RefractionAlgorithm\n\nHughes refraction model.\n\nThis function was developed by G. Hughes [1] and was used in the SUNAEP software [2].\n\nIt is also used to calculate the refraction correction in the NOAA solar position algorithm using a fixed pressure of 101325 Pa and a temperature of 10 degrees Celsius.\n\nFields\n\npressure::Any: Annual average atmospheric pressure [Pascal]\ntemperature::Any: Annual average temperature [°C]\n\nConstructor\n\nHUGHES(): Uses default parameters: pressure = 101325 Pa, temperature = 12 °C\nHUGHES(pressure, temperature): Specify custom pressure [Pa] and temperature [°C]\n\nNotes\n\nThe equation to calculate the refraction correction is given by:\n\nFor 5° < elevation ≤ 90°:\n\nfrac581tan(el) - frac007tan(el)^3 + frac86 times 10^-5tan(el)^5\n\nFor -0.575° < elevation ≤ 5°:\n\nel cdot (-5182 + el cdot (1034 + el cdot (-1279 + el cdot 0711))) + 1735\n\nFor elevation ≤ -0.575°:\n\nfrac-20774tan(el)\n\nwhere el is the true (unrefracted) solar elevation angle.\n\nThe result is then corrected for temperature and pressure:\n\ntextRefract times frac283273 + T times fracP101325 times frac13600\n\nLiterature\n\nThis function was developed by [Hug85] and was used in the SUNAEP software [Zim81]. It is also used to calculate the refraction correction in the NOAA solar position algorithm using a fixed pressure of 101325 Pa and a temperature of 10 degrees Celsius.\n\nExample\n\nusing SolarPosition\n\n# Create Hughes refraction model with default parameters\nhughes = HUGHES()\n\n# Or specify custom atmospheric conditions\nhughes_custom = HUGHES(101325.0, 25.0)  # 25°C temperature\n\n# Apply refraction correction to elevation angle\nelevation = 30.0  # degrees\nrefraction_correction = refraction(hughes, elevation)\napparent_elevation = elevation + refraction_correction\n\n\n\n\n\n","category":"type"},{"location":"examples/basic/#basic-example","page":"Basic Example","title":"Basic Example","text":"","category":"section"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"This section demonstrates basic usage of SolarPosition.jl for calculating solar positions.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"First, we need to import the package along with some supporting packages. Although not strictly necessary, it is common to work with time zone-aware datetimes using the TimeZones.jl package.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"using SolarPosition\n\n# supporting packages\nusing Dates\nusing DataFrames\nusing TimeZones","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"We can define an observer location using the Observer struct, which takes latitude, longitude, and altitude (in meters) as arguments.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"obs = Observer(37.7749, -122.4194, 100.0)  # San Francisco","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"Finally, we can calculate the solar position for a specific date and time using the solar_position function. The time should be provided as a ZonedDateTime to ensure correct handling of time zones.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"tz = tz\"America/Los_Angeles\"\nzdt = ZonedDateTime(2023, 6, 21, 12, 0, 0, tz)  # Summer solstice noon\nposition = solar_position(obs, zdt)\n\nprintln(\"Solar position at summer solstice noon in San Francisco:\")\nprintln(\"Azimuth: $(round(position.azimuth, digits=2))°\")\nprintln(\"Elevation: $(round(position.elevation, digits=2))°\")","category":"page"},{"location":"examples/basic/#Choosing-a-Solar-Position-Algorithm","page":"Basic Example","title":"Choosing a Solar Position Algorithm","text":"","category":"section"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"By default, SolarPosition.jl uses the PSA (Plataforma Solar de Almería) algorithm. You can also explicitly specify which algorithm to use by passing it as an argument.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"# Use PSA algorithm (default, high accuracy ±0.0083°)\nposition_psa = solar_position(obs, zdt, PSA())\n\n# Use NOAA algorithm (±0.0167°)\nposition_noaa = solar_position(obs, zdt, NOAA())\n\nprintln(\"PSA - Azimuth: $(round(position_psa.azimuth, digits=2))°, Elevation: $(round(position_psa.elevation, digits=2))°\")\nprintln(\"NOAA - Azimuth: $(round(position_noaa.azimuth, digits=2))°, Elevation: $(round(position_noaa.elevation, digits=2))°\")","category":"page"},{"location":"examples/basic/#Using-DateTime-in-UTC","page":"Basic Example","title":"Using DateTime in UTC","text":"","category":"section"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"Alternatively, we can directly pass a DateTime (assumed to be in UTC)","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"zdt_utc = DateTime(zdt, UTC)\nposition_utc = solar_position(obs, zdt_utc)\nprintln(\"Azimuth (UTC): $(round(position_utc.azimuth, digits=2))°\")\nprintln(\"Elevation (UTC): $(round(position_utc.elevation, digits=2))°\")","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"It is also possible to calculate solar positions for multiple timestamps at once by passing a vector of ZonedDateTime or DateTime objects.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"# Generate hourly timestamps for a whole year\ntimes = ZonedDateTime(DateTime(2019), tz):Hour(1):ZonedDateTime(DateTime(2020), tz)\n\n# This returns a StructArray with solar position data\npositions = solar_position(obs, collect(times))","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"We can inspect the first few entries by converting to a DataFrame:","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"first(DataFrame(positions), 5)","category":"page"},{"location":"examples/basic/#Multiple-Timestamps-Example","page":"Basic Example","title":"Multiple Timestamps Example","text":"","category":"section"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"We can also calculate solar positions for a range of timestamps by creating an Observer object and collecting the time range into a vector.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"times = collect(DateTime(2019):Hour(1):DateTime(2020))\nposition_direct = solar_position(obs, times)\nfirst(DataFrame(position_direct), 5)","category":"page"},{"location":"deltat/#deltat","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"","category":"section"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"Delta T (ΔT) is the difference between Terrestrial Dynamical Time (TD) and Universal Time (UT):","category":"page"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"Delta T = TD - UT","category":"page"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"This correction is essential for accurate astronomical calculations because Earth's rotation rate is not constant. It varies due to tidal braking from the Moon, changes in Earth's moment of inertia, and other geophysical factors.","category":"page"},{"location":"deltat/#Implementation","page":"Delta T (ΔT)","title":"Implementation","text":"","category":"section"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"SolarPosition.jl implements ΔT calculation using polynomial expressions fitted to historical observations and modern measurements from atomic clocks, based on [NAS25] and [MS04]:","category":"page"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"Historical data (-500 to 1950): Based on eclipse observations\nModern era (1950-2005): Direct measurements from atomic clocks and radio observations\nFuture (2005-2050): Extrapolation based on recent trends\nFar past/future: Parabolic extrapolation formula","category":"page"},{"location":"deltat/#Usage","page":"Delta T (ΔT)","title":"Usage","text":"","category":"section"},{"location":"deltat/#SolarPosition.Positioning.calculate_deltat","page":"Delta T (ΔT)","title":"SolarPosition.Positioning.calculate_deltat","text":"calculate_deltat(year::Real, month::Real) -> Any\n\n\nCompute ΔT (Delta T), the difference between Terrestrial Dynamical Time (TD) and Universal Time (UT).\n\nΔT = TD - UT\n\nThis value is needed to convert between civil time (UT) and the uniform time scale used in astronomical calculations (TD). The value changes over time due to variations in Earth's rotation rate caused by tidal braking and other factors.\n\nArguments\n\nyear::Real: Calendar year (supports -1999 to 3000, with warnings outside this range)\nmonth::Real: Month as a real number (1-12, fractional values supported for interpolation)\n\nReturns\n\nFloat64: ΔT in seconds\n\nExamples\n\njulia> using SolarPosition.Positioning: calculate_deltat\n\njulia> calculate_deltat(2020, 6)\n71.85030032812497\n\njulia> using Dates\n\njulia> calculate_deltat(Date(2020, 6, 15))\n71.87173085145835\n\njulia> calculate_deltat(DateTime(2020, 6, 15, 12, 30))\n71.87173085145835\n\nLiterature\n\nThe polynomial expressions for ΔT are from [NAS25], based on the work by [MS04].\n\n\n\n\n\n","category":"function"},{"location":"deltat/#Examples","page":"Delta T (ΔT)","title":"Examples","text":"","category":"section"},{"location":"deltat/#Basic-Usage","page":"Delta T (ΔT)","title":"Basic Usage","text":"","category":"section"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"Calculate ΔT for a specific year and month:","category":"page"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"using SolarPosition.Positioning: calculate_deltat\n\n# Calculate ΔT for June 2020\ndt = calculate_deltat(2020, 6)\nprintln(\"ΔT ≈ $(round(dt, digits=2)) seconds\")","category":"page"},{"location":"deltat/#Using-Date-Objects","page":"Delta T (ΔT)","title":"Using Date Objects","text":"","category":"section"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"For more convenient usage with date objects:","category":"page"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"using SolarPosition.Positioning: calculate_deltat\nusing Dates\n\n# Using Date\ndate = Date(2020, 6, 15)\ndt1 = calculate_deltat(date)\n\n# Using DateTime\ndatetime = DateTime(2020, 6, 15, 12, 30, 45)\ndt2 = calculate_deltat(datetime)\n\n# Using ZonedDateTime\nusing TimeZones\nzdt = ZonedDateTime(2020, 6, 15, 12, 30, 45, tz\"UTC\")\ndt3 = calculate_deltat(zdt)\n\nprintln(\"Date: ΔT ≈ $(round(dt1, digits=2)) seconds\")\nprintln(\"DateTime: ΔT ≈ $(round(dt2, digits=2)) seconds\")\nprintln(\"ZonedDateTime: ΔT ≈ $(round(dt3, digits=2)) seconds\")","category":"page"},{"location":"deltat/#Historical-Values","page":"Delta T (ΔT)","title":"Historical Values","text":"","category":"section"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"Calculate ΔT for historical dates:","category":"page"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"using SolarPosition.Positioning: calculate_deltat\n\n# Ancient Rome (year 0)\ndt_ancient = calculate_deltat(0, 6)\nprintln(\"Year 0: ΔT ≈ $(round(dt_ancient, digits=0)) seconds\")\n\n# Early telescope era (1650)\ndt_1650 = calculate_deltat(1650, 6)\nprintln(\"Year 1650: ΔT ≈ $(round(dt_1650, digits=1)) seconds\")\n\n# Near zero around 1900\ndt_1900 = calculate_deltat(1900, 6)\nprintln(\"Year 1900: ΔT ≈ $(round(dt_1900, digits=1)) seconds\")","category":"page"},{"location":"deltat/#Plotting-Historical-Trend","page":"Delta T (ΔT)","title":"Plotting Historical Trend","text":"","category":"section"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"Visualize how ΔT has changed over time, similar to the measured values derived from telescopic observations:","category":"page"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"using SolarPosition.Positioning: calculate_deltat\nusing CairoMakie\n\n# Calculate ΔT for years 1600-2000 (historical measurements)\nyears = 1600:1:2000\ndeltat_values = [calculate_deltat(year, 6) for year in years]\n\n# Create plot with transparent background\nfig = Figure(size=(800, 500), backgroundcolor=:transparent, textcolor=\"#f5ab35\")\nax = Axis(fig[1, 1],\n    xlabel = \"Year\",\n    ylabel = \"ΔT (seconds)\",\n    title = \"Historical Values of the Earth's Clock Error\",\n    backgroundcolor=:transparent,\n    xgridvisible = false,\n    ygridvisible = false,\n    xticks = 1500:100:2000,\n    xminorticks = IntervalsBetween(5),\n    xminorticksvisible = true,\n    yminorticks = IntervalsBetween(5),\n    yminorticksvisible = true\n)\n\n# Plot the measured/calculated values\nlines!(ax, years, deltat_values,\n    linewidth=2.5,\n    color=:steelblue,\n    label=\"calculated\"\n)\n\n# Add a very long-term parabolic trend line\n# Using the formula: ΔT ≈ -20 + 32 * ((year - 1820) / 100)^2\n# This represents the parabolic trend centered around 1820-1825\ntrend_years = 1560:10:2050\ntrend_values = [-20 + 32 * ((y - 1820) / 100)^2 for y in trend_years]\nlines!(ax, trend_years, trend_values,\n    linewidth=2,\n    color=:steelblue,\n    linestyle=:dash,\n    label=\"very long-term trend\"\n)\n\naxislegend(ax, position=:lb, backgroundcolor=:transparent)\nxlims!(ax, 1500, 2000)\nylims!(ax, -50, 200)\n\nfig","category":"page"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"This plot is an attempt to reproduce the result of [MS04, Fig 1., page 329] and shows the measured values of ΔT derived from astronomical observations since 1600 CE.","category":"page"},{"location":"deltat/#Accuracy","page":"Delta T (ΔT)","title":"Accuracy","text":"","category":"section"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"The accuracy of ΔT calculations varies depending on the time period:","category":"page"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"Modern era (1950-2025): Very accurate (< 1 second)\nHistorical (1600-1950): Accurate to a few seconds\nMedieval (500-1600): Accuracy decreases to ~10-30 seconds\nAncient (< 500): Accuracy decreases significantly (~50-500 seconds)\nFuture predictions: Uncertainty increases with time","category":"page"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"The uncertainty in ΔT arises because Earth's rotation is affected by unpredictable factors like atmospheric circulation, ocean currents, and tectonic events. For more details on the polynomial expressions and methodology, see [NAS25] and [MS04].","category":"page"},{"location":"examples/plotting/#plotting-examples","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"","category":"section"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"SolarPosition.jl provides a plotting extension based on Makie.jl.","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"To use it, simply import both the SolarPosition and Makie packages:","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"using SolarPosition\nusing CairoMakie\nusing CairoMakie: Figure, Axis, PolarAxis\n\n# supporting packages\nusing Dates\nusing TimeZones\nusing DataFrames\n\nplotsDir = joinpath(dirname(pathof(SolarPosition)), \"..\", \"docs\", \"build\", \"plots\")\nmkpath(plotsDir)","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"This example notebook is based on the pvlib sun path example.","category":"page"},{"location":"examples/plotting/#Basic-Sun-Path-Plotting","page":"Using the Makie.jl plotting extension","title":"Basic Sun Path Plotting","text":"","category":"section"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"Let's start by defining an observer location and calculating solar positions for a whole year:","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"# Define observer location (New Delhi, India)\n# Parameters: latitude, longitude, altitude in meters\ntz = tz\"Asia/Kolkata\"\nobs = Observer(28.6, 77.2, 0.0)\n\n# Generate hourly timestamps for a whole year\ntimes = collect(ZonedDateTime(DateTime(2019), tz):Hour(1):ZonedDateTime(DateTime(2020), tz))\n\n# This returns a StructVector with solar position data\npositions = solar_position(obs, times)\n\n# For plotting, we need to create a DataFrame that includes the timestamps\ndf = DataFrame(positions)\ndf.datetime = times\n\n# We can inspect the first few entries\nfirst(df, 5)","category":"page"},{"location":"examples/plotting/#Simple-Sun-Path-Plot-in-Cartesian-Coordinates","page":"Using the Makie.jl plotting extension","title":"Simple Sun Path Plot in Cartesian Coordinates","text":"","category":"section"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"We can visualize solar positions in cartesian coordinates using the sunpathplot function:","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"fig = Figure(backgroundcolor = (:white, 0.0), textcolor= \"#f5ab35\")\nax = Axis(fig[1, 1], backgroundcolor = (:white, 0.0))\nsunpathplot!(ax, df, hour_labels = false)\nfig","category":"page"},{"location":"examples/plotting/#Polar-Coordinates-with-Hour-Labels","page":"Using the Makie.jl plotting extension","title":"Polar Coordinates with Hour Labels","text":"","category":"section"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"We can also work directly with a DataFrame. Note that for plotting we need to include the datetime information, so we add it to the DataFrame.","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"Plotting in polar coordinates with sunpathpolarplot may yield a more intuitive representation of the solar path. Here, we also enable hourly labels for better readability:","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"fig2 = Figure(backgroundcolor = :transparent, textcolor= \"#f5ab35\", size = (800, 600))\nax2 = PolarAxis(fig2[1, 1], backgroundcolor = \"#1f2424\")\n# ax2 = PolarAxis(fig2[1, 1], backgroundcolor = (:white, 0.0))\nsunpathpolarplot!(ax2, df, hour_labels = true)\n\n# Draw individual days\nline_objects = []\nfor (date, label) in [(Date(\"2019-03-21\"), \"Mar 21\"),\n                      (Date(\"2019-06-21\"), \"Jun 21\"),\n                      (Date(\"2019-12-21\"), \"Dec 21\")]\n    times = collect(ZonedDateTime(DateTime(date), tz):Minute(5):ZonedDateTime(DateTime(date) + Day(1), tz))\n    solpos = solar_position(obs, times)\n    above_horizon = solpos.elevation .> 0\n    day_df = DataFrame(solpos)\n    day_df.datetime = times\n    day_filtered = day_df[above_horizon, :]\n    line_obj = lines!(ax2, deg2rad.(day_filtered.azimuth), day_filtered.zenith,\n                      linewidth = 2, label = label)\n    push!(line_objects, line_obj)\nend\n\n# Add legend below the plot\nfig2[2, 1] = Legend(fig2, line_objects, [\"Mar 21\", \"Jun 21\", \"Dec 21\"],\n                    orientation = :horizontal, tellheight = true, backgroundcolor = :transparent)\nfig2\n\n# save(joinpath(plotsDir,\"sunpathpolarplot.png\"), fig2)","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"The figure-8 patterns are known as analemmas, which represent the sun's position at the same time of day throughout the year.","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"Note that in polar coordinates, the radial distance from the center represents the zenith angle (90° - elevation). Thus, points closer to the center indicate higher elevations. Conversely, a zenith angle of more than 90° (negative elevation) indicates that the sun is below the horizon. Tracing a path from right to left corresponds to the sun's movement from east to west.","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"It tells us when the sun rises, reaches its highest point, and sets. And hence also the length of the day. From the figure we can also read that in June the days are longest, while in December they are shortest.","category":"page"},{"location":"examples/plotting/#Plotting-without-a-custom-axis","page":"Using the Makie.jl plotting extension","title":"Plotting without a custom axis","text":"","category":"section"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"Finally, we can also create plots without explicitly defining an axis beforehand. This is a more concise way to create plots, but it offers less customization:","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"sunpathpolarplot(df, hour_labels = true, colorbar = true)","category":"page"},{"location":"contributing/#contributing","page":"Contributing guidelines","title":"Contributing guidelines","text":"","category":"section"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"First of all, thanks for the interest!","category":"page"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"We welcome all kinds of contribution, including, but not limited to code, documentation, examples, configuration, issue creating, etc.","category":"page"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"Be polite and respectful.","category":"page"},{"location":"contributing/#Bug-reports-and-discussions","page":"Contributing guidelines","title":"Bug reports and discussions","text":"","category":"section"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"If you think you found a bug, feel free to open an issue. Focused suggestions and requests can also be opened as issues. Before opening a pull request, start an issue or a discussion on the topic, please.","category":"page"},{"location":"contributing/#Working-on-an-issue","page":"Contributing guidelines","title":"Working on an issue","text":"","category":"section"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"If you found an issue that interests you, comment on that issue what your plans are. If the solution to the issue is clear, you can immediately create a pull request (see below). Otherwise, say what your proposed solution is and wait for a discussion around it.","category":"page"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"tip: Tip\nFeel free to ping us after a few days if there are no responses.","category":"page"},{"location":"reference/#reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"reference/","page":"API reference","title":"API reference","text":"This page provides comprehensive documentation for all functions and types in SolarPosition.jl.","category":"page"},{"location":"reference/#Contents","page":"API reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"API reference","title":"API reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"API reference","title":"API reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#Core-Functions","page":"API reference","title":"Core Functions","text":"","category":"section"},{"location":"reference/#SolarPosition.Positioning.solar_position","page":"API reference","title":"SolarPosition.Positioning.solar_position","text":"Calculate solar position(s) for given observer location(s) and time(s).\n\nThis function computes the solar position (azimuth, elevation, and zenith angles) based on an observer's geographic location and timestamp(s). It supports multiple input formats and automatically handles time zone conversions.\n\n\n\nArguments\n\nobs::Observer: Observer location with latitude, longitude, and altitude\ndt::DateTime or dt::ZonedDateTime: Single timestamp\ndts::AbstractVector{DateTime} or dts::AbstractVector{ZonedDateTime}: Multiple timestamps\nalg::SolarAlgorithm: Solar positioning algorithm (default: PSA())\nrefraction::RefractionAlgorithm: Atmospheric refraction correction (default: NoRefraction())\n\n\n\nReturns\n\nFor single timestamps:\nSolPos struct when refraction = NoRefraction() (default)\nApparentSolPos struct when a refraction algorithm is provided\nFor multiple timestamps: StructVector of solar position data\n\n\n\nAngles Convention\n\nAll returned angles are in degrees:\n\nAzimuth: 0° = North, positive clockwise, range [-180°, 180°]\nElevation: angle above horizon, range [-90°, 90°]\nZenith: angle from zenith (90° - elevation), range [0°, 180°]\nApparent Elevation/Zenith: Only in ApparentSolPos, includes atmospheric refraction\n\n\n\nExamples\n\nSingle timestamp calculation (basic position)\n\nusing SolarPosition, Dates, TimeZones\n\n# Define observer location (San Francisco)\nobs = Observer(37.7749, -122.4194, 100.0)\n\n# Calculate position at specific time\ndt = ZonedDateTime(2023, 6, 21, 12, 0, 0, tz\"America/Los_Angeles\")\npos = solar_position(obs, dt)\n\nprintln(\"Azimuth: $(pos.azimuth)°\")\nprintln(\"Elevation: $(pos.elevation)°\")\nprintln(\"Zenith: $(pos.zenith)°\")\n\nWith refraction correction\n\n# Use a refraction algorithm (when implemented)\n# pos_apparent = solar_position(obs, dt, PSA(), MyRefractionAlg())\n# println(\"Apparent Elevation: $(pos_apparent.apparent_elevation)°\")\n\nMultiple timestamps calculation\n\n# Generate hourly timestamps for a day\ntimes = collect(DateTime(2023, 6, 21):Hour(1):DateTime(2023, 6, 22))\npositions = solar_position(obs, times)\n\n# Access as StructVector (acts like array of structs)\nprintln(\"First position: \", positions[1])\nprintln(\"All azimuths: \", positions.azimuth)\n\nUsing different algorithms\n\n# Use NOAA algorithm instead of default PSA\npos_noaa = solar_position(obs, dt, NOAA())\n\nSupported Input Types\n\nObserver: Observer{T} struct with lat/lon/altitude\nSingle time: DateTime, ZonedDateTime\nMultiple times: Vector{DateTime}, Vector{ZonedDateTime}\nAlgorithm: Any SolarAlgorithm subtype\nRefraction: Any RefractionAlgorithm subtype (default: NoRefraction())\n\nTime Zone Handling\n\nDateTime inputs are assumed to be in UTC\nZonedDateTime inputs are automatically converted to UTC\nFor local solar time calculations, use appropriate time zones\n\nPerformance Notes\n\nVectorized operations are optimized for multiple timestamps\nType-stable implementations for both Float32 and Float64\nBroadcasting-friendly for large datasets\n\nSee also: solar_position!, Observer, PSA, NOAA\n\n\n\n\n\n","category":"function"},{"location":"reference/#SolarPosition.Positioning.solar_position!","page":"API reference","title":"SolarPosition.Positioning.solar_position!","text":"solar_position!(table, obs::Observer; dt_col::Symbol=:datetime, alg::SolarAlgorithm=PSA(), refraction::RefractionAlgorithm=NoRefraction(), kwargs...)\nsolar_position!(table; latitude::AbstractFloat, longitude::AbstractFloat,\n                altitude::AbstractFloat=0.0, alg::SolarAlgorithm=PSA(), refraction::RefractionAlgorithm=NoRefraction(), kwargs...)\n\nCompute solar positions for all times in a table and add the results as new columns.\n\nArguments\n\ntable : Table-like object with datetime column (must support Tables.jl interface).\nobs::Observer : Observer location (latitude, longitude, altitude).\nlatitude, longitude, altitude : Specify observer location directly.\ndt_col::Symbol : Name of the datetime column (default: :datetime).\nalg::SolarAlgorithm : Algorithm to use (default: PSA()).\nrefraction::RefractionAlgorithm : Refraction correction (default: NoRefraction()).\nkwargs... : Additional keyword arguments forwarded to the algorithm.\n\nReturns\n\nModified table with added columns: azimuth, elevation, zenith.\nIf refraction is applied: also adds apparent_elevation, apparent_zenith.\n\nNotes\n\nThe input table is modified in-place by adding new columns.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Observer-and-Position-Types","page":"API reference","title":"Observer and Position Types","text":"","category":"section"},{"location":"reference/#SolarPosition.Positioning.Observer","page":"API reference","title":"SolarPosition.Positioning.Observer","text":"Observer{T} where {T<:AbstractFloat}\n\nObserver location (deg  rees, meters). Accepts a type parameter T for the floating point type to use (e.g. Float32, Float64).\n\n\n\nlatitude::AbstractFloat: Geodetic latitude (+N)\nlongitude::AbstractFloat: Longitude (+E)\naltitude::AbstractFloat: Altitude above mean sea level (meters)\nlatitude_rad::AbstractFloat: Latitude in radians\nlongitude_rad::AbstractFloat: Longitude in radians\nsin_lat::AbstractFloat: sin(latitude)\ncos_lat::AbstractFloat: cos(latitude)\n\n\n\n\n\n","category":"type"},{"location":"reference/#SolarPosition.Positioning.SolPos","page":"API reference","title":"SolarPosition.Positioning.SolPos","text":"struct SolPos{T} <: SolarPosition.Positioning.AbstractSolPos\n\nRepresents a single solar position calculated for a given observer and time.\n\n\n\nazimuth::Any: Azimuth (degrees, 0=N, +clockwise, range [-180, 180])\nelevation::Any: Elevation (degrees, range [-90, 90])\nzenith::Any: Zenith = 90 - elevation (degrees, range [0, 180])\n\n\n\n\n\n","category":"type"},{"location":"reference/#SolarPosition.Positioning.ApparentSolPos","page":"API reference","title":"SolarPosition.Positioning.ApparentSolPos","text":"struct ApparentSolPos{T} <: SolarPosition.Positioning.AbstractSolPos\n\nRepresents a single solar position calculated for a given observer and time. Also includes apparent elevation and zenith angles.\n\n\n\nazimuth::Any: Azimuth (degrees, 0=N, +clockwise, range [-180, 180])\nelevation::Any: Elevation (degrees, range [-90, 90])\nzenith::Any: Zenith = 90 - elevation (degrees, range [0, 180])\napparent_elevation::Any: Apparent elevation (degrees, range [-90, 90])\napparent_zenith::Any: Apparent zenith (degrees, range [0, 180])\n\n\n\n\n\n","category":"type"},{"location":"reference/#Algorithm-Base-Types","page":"API reference","title":"Algorithm Base Types","text":"","category":"section"},{"location":"reference/","page":"API reference","title":"API reference","text":"SolarPosition.jl uses a type hierarchy for algorithms:","category":"page"},{"location":"reference/#SolarPosition.Positioning.SolarAlgorithm","page":"API reference","title":"SolarPosition.Positioning.SolarAlgorithm","text":"SolarAlgorithm\n\nAbstract base type for all solar position algorithms.\n\nAll concrete solar position algorithm types must inherit from this type.\n\nExamples\n\nstruct MyAlgorithm <: SolarAlgorithm end\n\n\n\n\n\n","category":"type"},{"location":"reference/#SolarPosition.Refraction.RefractionAlgorithm","page":"API reference","title":"SolarPosition.Refraction.RefractionAlgorithm","text":"RefractionAlgorithm\n\nAbstract base type for atmospheric refraction correction algorithms.\n\nRefraction algorithms compute the apparent position of the sun by correcting for atmospheric refraction effects.\n\nExamples\n\nstruct MyRefraction <: RefractionAlgorithm end\n\n\n\n\n\n","category":"type"},{"location":"reference/#Modules","page":"API reference","title":"Modules","text":"","category":"section"},{"location":"reference/#SolarPosition.Positioning","page":"API reference","title":"SolarPosition.Positioning","text":"Positioning\n\nCollection of solar positioning algorithms and related functionality.\n\nThis module provides the core solar position calculation algorithms, observer location handling, and result types for SolarPosition.jl. It includes implementations of various solar position algorithms such as PSA and NOAA, with support for optional atmospheric refraction corrections.\n\nExported Types\n\nObserver: Geographic observer location\nSolPos: Basic solar position result\nApparentSolPos: Solar position with atmospheric corrections\nPSA: PSA algorithm implementation\nNOAA: NOAA algorithm implementation\nRefractionAlgorithm: Base type for refraction algorithms\nNoRefraction: No refraction correction (default)\n\nExported Functions\n\nsolar_position: Calculate solar positions\nsolar_position!: In-place solar position calculation\n\n\n\n\n\n","category":"module"},{"location":"reference/#SolarPosition.Refraction","page":"API reference","title":"SolarPosition.Refraction","text":"Refraction\n\nAtmospheric refraction models.\n\nExported Types\n\nHUGHES: Hughes atmospheric refraction model\n\nExported Functions\n\nrefraction: Apply refraction correction to elevation angle(s)\n\n\n\n\n\n","category":"module"},{"location":"#SolarPosition.jl","page":"SolarPosition.jl","title":"SolarPosition.jl","text":"","category":"section"},{"location":"","page":"SolarPosition.jl","title":"SolarPosition.jl","text":"SolarPosition.jl provides a simple, unified interface to a collection of solar position algorithms written in pure, performant julia. The position of the sun in the sky is based on date, time, and a given observer location.","category":"page"},{"location":"","page":"SolarPosition.jl","title":"SolarPosition.jl","text":"A solar position algorithm is commonly used to calculate the solar zenith and azimuth angles, which are essential for various applications such as solar energy systems, building design, and climate studies.","category":"page"},{"location":"#Solar-positioning-algorithms","page":"SolarPosition.jl","title":"Solar positioning algorithms","text":"","category":"section"},{"location":"","page":"SolarPosition.jl","title":"SolarPosition.jl","text":"Here we provide an overview of the solar positioning algorithms currently implemented in SolarPosition.jl. Each algorithm is described with its reference paper, claimed accuracy and implementation status.","category":"page"},{"location":"","page":"SolarPosition.jl","title":"SolarPosition.jl","text":"Algorithm Reference Accuracy Status\nPSA [BALL01] ±0.0083° ✅\nNOAA [NOA25] ±0.0167° ✅","category":"page"},{"location":"literature/#Literature","page":"Literature","title":"Literature","text":"","category":"section"},{"location":"literature/","page":"Literature","title":"Literature","text":"This page contains the complete bibliography of references used throughout the SolarPosition.jl documentation and source code.","category":"page"},{"location":"literature/#References","page":"Literature","title":"References","text":"","category":"section"},{"location":"literature/","page":"Literature","title":"Literature","text":"M. J. Blanco, K. Milidonis and A. M. Bonanos. Updating the PSA sun position algorithm. Solar Energy 212, 339–341 (2020).\n\n\n\nM. Blanco-Muriel, D. C. Alarcón-Padilla, T. López-Moratalla and M. Lara-Coira. Computing the solar vector. Solar Energy 70, 431–441 (2001).\n\n\n\nG. W. Hughes. Engineering Astronomy (Sandia Laboratories, 1985).\n\n\n\nJ. Meeus. Astronomical Algorithms. 1st Edition (Willmann-Bell, 1991).\n\n\n\nL. V. Morrison and F. R. Stephenson. Historical values of the Earth's clock error DeltaT and the calculation of eclipses. Journal for the History of Astronomy 35, 327–336 (2004).\n\n\n\nJ. C. Zimmerman. Sun-pointing programs and their accuracy. Technical Report SAND-81-0761 (Sandia National Laboratories, 1981).\n\n\n\nNASA Goddard Space Flight Center. Polynomial Expressions for Delta T (DeltaT) (2025). Accessed: 2025-10-15.\n\n\n\nNOAA Global Monitoring Laboratory. Solar Position Calculator (2025). Accessed: 2025-10-15.\n\n\n\n","category":"page"},{"location":"algorithms/#algorithms","page":"Positioning Algorithms","title":"Positioning Algorithms","text":"","category":"section"},{"location":"algorithms/","page":"Positioning Algorithms","title":"Positioning Algorithms","text":"Solar position algorithms available in SolarPosition.jl.","category":"page"},{"location":"algorithms/","page":"Positioning Algorithms","title":"Positioning Algorithms","text":"Algorithm Reference Accuracy Status\nPSA [BALL01] ±0.0083° ✅\nNOAA [NOA25] ±0.0167° ✅","category":"page"},{"location":"algorithms/#psa-algorithm","page":"Positioning Algorithms","title":"PSA","text":"","category":"section"},{"location":"algorithms/","page":"Positioning Algorithms","title":"Positioning Algorithms","text":"The PSA (Plataforma Solar de Almería) algorithm is the default high-accuracy solar position algorithm.","category":"page"},{"location":"algorithms/","page":"Positioning Algorithms","title":"Positioning Algorithms","text":"The algorithm was originally published by [BALL01] and was later updated by [BMB20] with new coefficients for improved accuracy.","category":"page"},{"location":"algorithms/#SolarPosition.Positioning.PSA","page":"Positioning Algorithms","title":"SolarPosition.Positioning.PSA","text":"struct PSA <: SolarPosition.Positioning.SolarAlgorithm\n\nPSA (Plataforma Solar de Almería) solar position algorithm.\n\nThis algorithm computes solar position with high accuracy using empirical coefficients. Two coefficient sets are available: 2001 (range 1999-2015) and 2020 (range 2020-2050).\n\nFields\n\ncoeffs::Int64: Coefficient set year (2001 or 2020)\n\nConstructor\n\nPSA(): Uses 2020 coefficients (default)\nPSA(2020): Uses 2020 coefficients (range 2020-2050, accuracy ±0.0083°)\nPSA(2001): Uses 2001 coefficients (range 1999-2015, accuracy ±0.0083°)\n\nLiterature\n\nThis algorithm is based on the work by [BALL01] and was updated in [BMB20].\n\nExample\n\njulia> pos = solar_position(obs, dt, PSA())\nSolPos{Float64}(51.2154455981643, -8.618482096636027, 98.61848209663603)\n\njulia> pos_historical = solar_position(obs, dt, PSA(2001))\nSolPos{Float64}(51.21527503642826, -8.618604682115866, 98.61860468211586)\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#noaa-algorithm","page":"Positioning Algorithms","title":"NOAA","text":"","category":"section"},{"location":"algorithms/","page":"Positioning Algorithms","title":"Positioning Algorithms","text":"The NOAA (National Oceanic and Atmospheric Administration) algorithm provides an alternative implementation based on [NOA25].","category":"page"},{"location":"algorithms/#SolarPosition.Positioning.NOAA","page":"Positioning Algorithms","title":"SolarPosition.Positioning.NOAA","text":"struct NOAA <: SolarPosition.Positioning.SolarAlgorithm\n\nNOAA (National Oceanic and Atmospheric Administration) solar position algorithm.\n\nThis algorithm is based on NOAA's Solar Position Calculator implementation. The algorithm is from \"Astronomical Algorithms\" by Jean Meeus.\n\nAccuracy\n\nClaimed accuracy: ±0.0167° from years -2000 to +3000 for latitudes within ±72°. For latitudes outside this range, the accuracy is ±0.167°.\n\nLiterature\n\nBased on the NOAA solar position calculator [NOA25] and the work by [Mee91].\n\nFields\n\ndelta_t::Union{Nothing, Float64}: Difference between terrestrial time and UT1 [seconds]. If nothing, uses automatic calculation.\n\nExample\n\njulia> using Dates, TimeZones\n\njulia> obs = Observer(52.52, 13.41);  # Berlin\n\njulia> dt = ZonedDateTime(2024, 6, 21, 12, 0, 0, tz\"UTC\");\n\njulia> pos = solar_position(obs, dt, NOAA());\n\njulia> typeof(pos)\nSolPos{Float64}\n\n\n\n\n\n","category":"type"}]
}
