var documenterSearchIndex = {"docs":
[{"location":"examples/plotting/#plotting-examples","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"","category":"section"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"SolarPosition.jl provides a plotting extension based on Makie.jl.","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"To use it, simply import both the SolarPosition and Makie packages:","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"using SolarPosition\nusing CairoMakie\nusing CairoMakie: Figure, Axis, PolarAxis\n\n# supporting packages\nusing Dates\nusing TimeZones\nusing DataFrames\n\nplotsDir = joinpath(dirname(pathof(SolarPosition)), \"..\", \"docs\", \"build\", \"plots\")\nmkpath(plotsDir)","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"This example notebook is based on the pvlib sun path example.","category":"page"},{"location":"examples/plotting/#Basic-Sun-Path-Plotting","page":"Using the Makie.jl plotting extension","title":"Basic Sun Path Plotting","text":"","category":"section"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"Let's start by defining an observer location and calculating solar positions for a whole year:","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"# Define observer location (New Delhi, India)\n# Parameters: latitude, longitude, altitude in meters\ntz = tz\"Asia/Kolkata\"\nobs = Observer(28.6, 77.2, 0.0)\n\n# Generate hourly timestamps for a whole year\ntimes = collect(ZonedDateTime(DateTime(2019), tz):Hour(1):ZonedDateTime(DateTime(2020), tz))\n\n# This returns a StructVector with solar position data\npositions = solar_position(obs, times)\n\n# For plotting, we need to create a DataFrame that includes the timestamps\ndf = DataFrame(positions)\ndf.datetime = times\n\n# We can inspect the first few entries\nfirst(df, 5)","category":"page"},{"location":"examples/plotting/#Simple-Sun-Path-Plot-in-Cartesian-Coordinates","page":"Using the Makie.jl plotting extension","title":"Simple Sun Path Plot in Cartesian Coordinates","text":"","category":"section"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"We can visualize solar positions in cartesian coordinates using the sunpathplot function:","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"fig = Figure(backgroundcolor = (:white, 0.0), textcolor= \"#f5ab35\")\nax = Axis(fig[1, 1], backgroundcolor = (:white, 0.0))\nsunpathplot!(ax, df, hour_labels = false)\nfig","category":"page"},{"location":"examples/plotting/#Polar-Coordinates-with-Hour-Labels","page":"Using the Makie.jl plotting extension","title":"Polar Coordinates with Hour Labels","text":"","category":"section"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"We can also work directly with a DataFrame. Note that for plotting we need to include the datetime information, so we add it to the DataFrame.","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"Plotting in polar coordinates with sunpathpolarplot may yield a more intuitive representation of the solar path. Here, we also enable hourly labels for better readability:","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"fig2 = Figure(backgroundcolor = :transparent, textcolor= \"#f5ab35\", size = (800, 600))\nax2 = PolarAxis(fig2[1, 1], backgroundcolor = \"#1f2424\")\n# ax2 = PolarAxis(fig2[1, 1], backgroundcolor = (:white, 0.0))\nsunpathpolarplot!(ax2, df, hour_labels = true)\n\n# Draw individual days\nline_objects = []\nfor (date, label) in [(Date(\"2019-03-21\"), \"Mar 21\"),\n                      (Date(\"2019-06-21\"), \"Jun 21\"),\n                      (Date(\"2019-12-21\"), \"Dec 21\")]\n    times = collect(ZonedDateTime(DateTime(date), tz):Minute(5):ZonedDateTime(DateTime(date) + Day(1), tz))\n    solpos = solar_position(obs, times)\n    above_horizon = solpos.elevation .> 0\n    day_df = DataFrame(solpos)\n    day_df.datetime = times\n    day_filtered = day_df[above_horizon, :]\n    line_obj = lines!(ax2, deg2rad.(day_filtered.azimuth), day_filtered.zenith,\n                      linewidth = 2, label = label)\n    push!(line_objects, line_obj)\nend\n\n# Add legend below the plot\nfig2[2, 1] = Legend(fig2, line_objects, [\"Mar 21\", \"Jun 21\", \"Dec 21\"],\n                    orientation = :horizontal, tellheight = true, backgroundcolor = :transparent)\nfig2\n\n# save(joinpath(plotsDir,\"sunpathpolarplot.png\"), fig2)","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"The figure-8 patterns are known as analemmas, which represent the sun's position at the same time of day throughout the year.","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"Note that in polar coordinates, the radial distance from the center represents the zenith angle (90° - elevation). Thus, points closer to the center indicate higher elevations. Conversely, a zenith angle of more than 90° (negative elevation) indicates that the sun is below the horizon. Tracing a path from right to left corresponds to the sun's movement from east to west.","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"It tells us when the sun rises, reaches its highest point, and sets. And hence also the length of the day. From the figure we can also read that in June the days are longest, while in December they are shortest.","category":"page"},{"location":"examples/plotting/#Plotting-without-a-custom-axis","page":"Using the Makie.jl plotting extension","title":"Plotting without a custom axis","text":"","category":"section"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"Finally, we can also create plots without explicitly defining an axis beforehand. This is a more concise way to create plots, but it offers less customization:","category":"page"},{"location":"examples/plotting/","page":"Using the Makie.jl plotting extension","title":"Using the Makie.jl plotting extension","text":"sunpathpolarplot(df, hour_labels = true, colorbar = true)","category":"page"},{"location":"contributing/#contributing","page":"Contributing guidelines","title":"Contributing guidelines","text":"","category":"section"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"First of all, thanks for the interest!","category":"page"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"We welcome all kinds of contribution, including, but not limited to code, documentation, examples, configuration, issue creating, etc.","category":"page"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"Be polite and respectful.","category":"page"},{"location":"contributing/#Bug-reports-and-discussions","page":"Contributing guidelines","title":"Bug reports and discussions","text":"","category":"section"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"If you think you found a bug, feel free to open an issue. Focused suggestions and requests can also be opened as issues. Before opening a pull request, start an issue or a discussion on the topic, please.","category":"page"},{"location":"contributing/#Working-on-an-issue","page":"Contributing guidelines","title":"Working on an issue","text":"","category":"section"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"If you found an issue that interests you, comment on that issue what your plans are. If the solution to the issue is clear, you can immediately create a pull request (see below). Otherwise, say what your proposed solution is and wait for a discussion around it.","category":"page"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"tip: Tip\nFeel free to ping us after a few days if there are no responses.","category":"page"},{"location":"reference/#reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"reference/","page":"API reference","title":"API reference","text":"This page provides comprehensive documentation for all functions and types in SolarPosition.jl.","category":"page"},{"location":"reference/#Contents","page":"API reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"API reference","title":"API reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"API reference","title":"API reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#Core-Functions","page":"API reference","title":"Core Functions","text":"","category":"section"},{"location":"reference/#SolarPosition.Positioning.solar_position","page":"API reference","title":"SolarPosition.Positioning.solar_position","text":"Calculate solar position(s) for given observer location(s) and time(s).\n\nThis function computes the solar position (azimuth, elevation, and zenith angles) based on an observer's geographic location and timestamp(s). It supports multiple input formats and automatically handles time zone conversions.\n\n\n\nArguments\n\nobs::Observer: Observer location with latitude, longitude, and altitude\ndt::DateTime or dt::ZonedDateTime: Single timestamp\ndts::AbstractVector{DateTime} or dts::AbstractVector{ZonedDateTime}: Multiple timestamps\nalg::SolarAlgorithm: Solar positioning algorithm (default: PSA())\nrefraction::RefractionAlgorithm: Atmospheric refraction correction (default: NoRefraction())\n\n\n\nReturns\n\nFor single timestamps:\nSolPos struct when refraction = NoRefraction() (default)\nApparentSolPos struct when a refraction algorithm is provided\nFor multiple timestamps: StructVector of solar position data\n\n\n\nAngles Convention\n\nAll returned angles are in degrees:\n\nAzimuth: 0° = North, positive clockwise, range [-180°, 180°]\nElevation: angle above horizon, range [-90°, 90°]\nZenith: angle from zenith (90° - elevation), range [0°, 180°]\nApparent Elevation/Zenith: Only in ApparentSolPos, includes atmospheric refraction\n\n\n\nExamples\n\nSingle timestamp calculation (basic position)\n\nusing SolarPosition, Dates, TimeZones\n\n# Define observer location (San Francisco)\nobs = Observer(37.7749, -122.4194, 100.0)\n\n# Calculate position at specific time\ndt = ZonedDateTime(2023, 6, 21, 12, 0, 0, tz\"America/Los_Angeles\")\npos = solar_position(obs, dt)\n\nprintln(\"Azimuth: $(pos.azimuth)°\")\nprintln(\"Elevation: $(pos.elevation)°\")\nprintln(\"Zenith: $(pos.zenith)°\")\n\nWith refraction correction\n\n# Use a refraction algorithm (when implemented)\n# pos_apparent = solar_position(obs, dt, PSA(), MyRefractionAlg())\n# println(\"Apparent Elevation: $(pos_apparent.apparent_elevation)°\")\n\nMultiple timestamps calculation\n\n# Generate hourly timestamps for a day\ntimes = collect(DateTime(2023, 6, 21):Hour(1):DateTime(2023, 6, 22))\npositions = solar_position(obs, times)\n\n# Access as StructVector (acts like array of structs)\nprintln(\"First position: \", positions[1])\nprintln(\"All azimuths: \", positions.azimuth)\n\nUsing different algorithms\n\n# Use NOAA algorithm instead of default PSA\npos_noaa = solar_position(obs, dt, NOAA())\n\nSupported Input Types\n\nObserver: Observer{T} struct with lat/lon/altitude\nSingle time: DateTime, ZonedDateTime\nMultiple times: Vector{DateTime}, Vector{ZonedDateTime}\nAlgorithm: Any SolarAlgorithm subtype\nRefraction: Any RefractionAlgorithm subtype (default: NoRefraction())\n\nTime Zone Handling\n\nDateTime inputs are assumed to be in UTC\nZonedDateTime inputs are automatically converted to UTC\nFor local solar time calculations, use appropriate time zones\n\nPerformance Notes\n\nVectorized operations are optimized for multiple timestamps\nType-stable implementations for both Float32 and Float64\nBroadcasting-friendly for large datasets\n\nSee also: solar_position!, Observer, PSA, NOAA\n\n\n\n\n\n","category":"function"},{"location":"reference/#SolarPosition.Positioning.solar_position!","page":"API reference","title":"SolarPosition.Positioning.solar_position!","text":"solar_position!(table, obs::Observer; dt_col::Symbol=:datetime, alg::SolarAlgorithm=PSA(), refraction::RefractionAlgorithm=NoRefraction(), kwargs...)\nsolar_position!(table; latitude::AbstractFloat, longitude::AbstractFloat,\n                altitude::AbstractFloat=0.0, alg::SolarAlgorithm=PSA(), refraction::RefractionAlgorithm=NoRefraction(), kwargs...)\n\nCompute solar positions for all times in a table and add the results as new columns.\n\nArguments\n\ntable : Table-like object with datetime column (must support Tables.jl interface).\nobs::Observer : Observer location (latitude, longitude, altitude).\nlatitude, longitude, altitude : Specify observer location directly.\ndt_col::Symbol : Name of the datetime column (default: :datetime).\nalg::SolarAlgorithm : Algorithm to use (default: PSA()).\nrefraction::RefractionAlgorithm : Refraction correction (default: NoRefraction()).\nkwargs... : Additional keyword arguments forwarded to the algorithm.\n\nReturns\n\nModified table with added columns: azimuth, elevation, zenith.\nIf refraction is applied: also adds apparent_elevation, apparent_zenith.\n\nNotes\n\nThe input table is modified in-place by adding new columns.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Observer-and-Position-Types","page":"API reference","title":"Observer and Position Types","text":"","category":"section"},{"location":"reference/#SolarPosition.Positioning.Observer","page":"API reference","title":"SolarPosition.Positioning.Observer","text":"Observer{T} where {T<:AbstractFloat}\n\nObserver location (deg  rees, meters). Accepts a type parameter T for the floating point type to use (e.g. Float32, Float64).\n\n\n\nlatitude::AbstractFloat: Geodetic latitude (+N)\nlongitude::AbstractFloat: Longitude (+E)\naltitude::AbstractFloat: Altitude above mean sea level (meters)\nlatitude_rad::AbstractFloat: Latitude in radians (automatically computed)\nlongitude_rad::AbstractFloat: Longitude in radians (automatically computed)\nsin_lat_rad::AbstractFloat: sin(latitude) in radians (automatically computed)\ncos_lat_rad::AbstractFloat: cos(latitude) in radians (automatically computed)\n\n\n\n\n\n","category":"type"},{"location":"reference/#SolarPosition.Positioning.SolPos","page":"API reference","title":"SolarPosition.Positioning.SolPos","text":"struct SolPos{T} <: SolarPosition.Positioning.AbstractSolPos\n\nRepresents a single solar position calculated for a given observer and time.\n\n\n\nazimuth::Any: Azimuth (degrees, 0=N, +clockwise, range [-180, 180])\nelevation::Any: Elevation (degrees, range [-90, 90])\nzenith::Any: Zenith = 90 - elevation (degrees, range [0, 180])\n\n\n\n\n\n","category":"type"},{"location":"reference/#SolarPosition.Positioning.ApparentSolPos","page":"API reference","title":"SolarPosition.Positioning.ApparentSolPos","text":"struct ApparentSolPos{T} <: SolarPosition.Positioning.AbstractSolPos\n\nRepresents a single solar position calculated for a given observer and time. Also includes apparent elevation and zenith angles.\n\n\n\nazimuth::Any: Azimuth (degrees, 0=N, +clockwise, range [-180, 180])\nelevation::Any: Elevation (degrees, range [-90, 90])\nzenith::Any: Zenith = 90 - elevation (degrees, range [0, 180])\napparent_elevation::Any: Apparent elevation (degrees, range [-90, 90])\napparent_zenith::Any: Apparent zenith (degrees, range [0, 180])\n\n\n\n\n\n","category":"type"},{"location":"reference/#Algorithm-Base-Types","page":"API reference","title":"Algorithm Base Types","text":"","category":"section"},{"location":"reference/","page":"API reference","title":"API reference","text":"SolarPosition.jl uses a type hierarchy for algorithms:","category":"page"},{"location":"reference/#SolarPosition.Positioning.SolarAlgorithm","page":"API reference","title":"SolarPosition.Positioning.SolarAlgorithm","text":"SolarAlgorithm\n\nAbstract base type for all solar position algorithms.\n\nAll concrete solar position algorithm types must inherit from this type.\n\nExamples\n\nstruct MyAlgorithm <: SolarAlgorithm end\n\n\n\n\n\n","category":"type"},{"location":"reference/#Refraction-Types","page":"API reference","title":"Refraction Types","text":"","category":"section"},{"location":"reference/","page":"API reference","title":"API reference","text":"Atmospheric refraction correction is controlled via refraction algorithm types:","category":"page"},{"location":"reference/#SolarPosition.Refraction.RefractionAlgorithm","page":"API reference","title":"SolarPosition.Refraction.RefractionAlgorithm","text":"RefractionAlgorithm\n\nAbstract base type for atmospheric refraction correction algorithms.\n\nRefraction algorithms compute the apparent position of the sun by correcting for atmospheric refraction effects.\n\nExamples\n\nstruct MyRefraction <: RefractionAlgorithm end\n\n\n\n\n\n","category":"type"},{"location":"reference/#SolarPosition.Refraction.NoRefraction","page":"API reference","title":"SolarPosition.Refraction.NoRefraction","text":"NoRefraction <: RefractionAlgorithm\n\nIndicates that no atmospheric refraction correction should be applied.\n\nThis is the default refraction setting for solar position calculations. When used, only basic solar position (azimuth, elevation, zenith) is computed.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SolarPosition.Refraction.HUGHES","page":"API reference","title":"SolarPosition.Refraction.HUGHES","text":"struct HUGHES{T} <: RefractionAlgorithm\n\nHughes refraction model.\n\nThis function was developed by G. Hughes [1] and was used in the SUNAEP software [2].\n\nIt is also used to calculate the refraction correction in the NOAA solar position algorithm using a fixed pressure of 101325 Pa and a temperature of 10 degrees Celsius.\n\nFields\n\npressure::Any: Annual average atmospheric pressure [Pascal]\ntemperature::Any: Annual average temperature [°C]\n\nConstructor\n\nHUGHES(): Uses default parameters: pressure = 101325 Pa, temperature = 12 °C\nHUGHES(pressure, temperature): Specify custom pressure [Pa] and temperature [°C]\n\nNotes\n\nThe equation to calculate the refraction correction is given by:\n\nFor 5° < elevation ≤ 90°:\n\nfrac581tan(el) - frac007tan(el)^3 + frac86 times 10^-5tan(el)^5\n\nFor -0.575° < elevation ≤ 5°:\n\nel cdot (-5182 + el cdot (1034 + el cdot (-1279 + el cdot 0711))) + 1735\n\nFor elevation ≤ -0.575°:\n\nfrac-20774tan(el)\n\nwhere el is the true (unrefracted) solar elevation angle.\n\nThe result is then corrected for temperature and pressure:\n\ntextRefract times frac283273 + T times fracP101325 times frac13600\n\nReferences\n\n[1] G. W. Hughes, \"Engineering Astronomy,\" Sandia Laboratories, 1985,     https://pvpmc.sandia.gov/app/uploads/sites/243/2022/10/Engineering-Astronomy.pdf\n\n[2] J. C. Zimmerman, \"Sun-pointing programs and their accuracy,\"     SANDIA Technical Report SAND-81-0761, 1981, DOI: 10.2172/6377969\n\nExample\n\nusing SolarPosition\n\n# Create Hughes refraction model with default parameters\nhughes = HUGHES()\n\n# Or specify custom atmospheric conditions\nhughes_custom = HUGHES(101325.0, 25.0)  # 25°C temperature\n\n# Apply refraction correction to elevation angle\nelevation = 30.0  # degrees\nrefraction_correction = refraction(hughes, elevation)\napparent_elevation = elevation + refraction_correction\n\n\n\n\n\n","category":"type"},{"location":"reference/#SolarPosition.Refraction.refraction","page":"API reference","title":"SolarPosition.Refraction.refraction","text":"refraction(model::RefractionAlgorithm, elevation::T) where {T<:AbstractFloat}\n\nApply atmospheric refraction correction to the given elevation angle(s).\n\nArguments\n\nmodel::RefractionAlgorithm: Refraction model to use (e.g., HUGHES())\nelevation::T: True (unrefracted) solar elevation angle in degrees\n\nReturns\n\nRefraction correction in degrees to be added to the elevation angle\n\nExamples\n\nusing SolarPosition\nhughes = HUGHES(101325.0, 15.0)  # 15°C temperature\nelevation = 30.0  # 30 degrees\ncorrection = refraction(hughes, elevation)\napparent_elevation = elevation + correction\n\n\n\n\n\n","category":"function"},{"location":"reference/#Modules","page":"API reference","title":"Modules","text":"","category":"section"},{"location":"reference/#SolarPosition.Positioning","page":"API reference","title":"SolarPosition.Positioning","text":"Positioning\n\nCollection of solar positioning algorithms and related functionality.\n\nThis module provides the core solar position calculation algorithms, observer location handling, and result types for SolarPosition.jl. It includes implementations of various solar position algorithms such as PSA and NOAA, with support for optional atmospheric refraction corrections.\n\nExported Types\n\nObserver: Geographic observer location\nSolPos: Basic solar position result\nApparentSolPos: Solar position with atmospheric corrections\nPSA: PSA algorithm implementation\nNOAA: NOAA algorithm implementation\nRefractionAlgorithm: Base type for refraction algorithms\nNoRefraction: No refraction correction (default)\n\nExported Functions\n\nsolar_position: Calculate solar positions\nsolar_position!: In-place solar position calculation\n\n\n\n\n\n","category":"module"},{"location":"reference/#SolarPosition.Refraction","page":"API reference","title":"SolarPosition.Refraction","text":"Refraction\n\nAtmospheric refraction models.\n\nExported Types\n\nHUGHES: Hughes atmospheric refraction model\n\nExported Functions\n\nrefraction: Apply refraction correction to elevation angle(s)\n\n\n\n\n\n","category":"module"},{"location":"#SolarPosition.jl","page":"SolarPosition.jl","title":"SolarPosition.jl","text":"","category":"section"},{"location":"","page":"SolarPosition.jl","title":"SolarPosition.jl","text":"SolarPosition.jl provides a simple, unified interface to a collection of solar position algorithms written in pure, performant julia. The position of the sun in the sky is based on date, time, and a given observer location.","category":"page"},{"location":"","page":"SolarPosition.jl","title":"SolarPosition.jl","text":"A solar position algorithm is commonly used to calculate the solar zenith and azimuth angles, which are essential for various applications such as solar energy systems, building design, and climate studies.","category":"page"},{"location":"#Solar-positioning-algorithms","page":"SolarPosition.jl","title":"Solar positioning algorithms","text":"","category":"section"},{"location":"","page":"SolarPosition.jl","title":"SolarPosition.jl","text":"Here we provide an overview of the solar positioning algorithms currently implemented in SolarPosition.jl. Each algorithm is described with its reference paper, claimed accuracy and implementation status.","category":"page"},{"location":"","page":"SolarPosition.jl","title":"SolarPosition.jl","text":"Algorithm Reference Accuracy Status\nPSA Blanco-Muriel et al. ±0.0083° ✅\nNOAA Global Monitoring Laboratory ±0.0167° ❌","category":"page"},{"location":"examples/basic/#basic-example","page":"Basic Example","title":"Basic Example","text":"","category":"section"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"This section demonstrates basic usage of SolarPosition.jl for calculating solar positions.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"First, we need to import the package along with some supporting packages. Although not strictly necessary, it is common to work with time zone-aware datetimes using the TimeZones.jl package.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"using SolarPosition\n\n# supporting packages\nusing Dates\nusing DataFrames\nusing TimeZones","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"We can define an observer location using the Observer struct, which takes latitude, longitude, and altitude (in meters) as arguments.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"obs = Observer(37.7749, -122.4194, 100.0)  # San Francisco","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"Finally, we can calculate the solar position for a specific date and time using the solar_position function. The time should be provided as a ZonedDateTime to ensure correct handling of time zones.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"tz = tz\"America/Los_Angeles\"\nzdt = ZonedDateTime(2023, 6, 21, 12, 0, 0, tz)  # Summer solstice noon\nposition = solar_position(obs, zdt)\n\nprintln(\"Solar position at summer solstice noon in San Francisco:\")\nprintln(\"Azimuth: $(round(position.azimuth, digits=2))°\")\nprintln(\"Elevation: $(round(position.elevation, digits=2))°\")","category":"page"},{"location":"examples/basic/#Using-DateTime-in-UTC","page":"Basic Example","title":"Using DateTime in UTC","text":"","category":"section"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"Alternatively, we can directly pass a DateTime (assumed to be in UTC)","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"zdt_utc = DateTime(zdt, UTC)\nposition_utc = solar_position(obs, zdt_utc)\nprintln(\"Azimuth (UTC): $(round(position_utc.azimuth, digits=2))°\")\nprintln(\"Elevation (UTC): $(round(position_utc.elevation, digits=2))°\")","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"It is also possible to calculate solar positions for multiple timestamps at once by passing a vector of ZonedDateTime or DateTime objects.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"# Generate hourly timestamps for a whole year\ntimes = ZonedDateTime(DateTime(2019), tz):Hour(1):ZonedDateTime(DateTime(2020), tz)\n\n# This returns a StructArray with solar position data\npositions = solar_position(obs, collect(times))","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"We can inspect the first few entries by converting to a DataFrame:","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"first(DataFrame(positions), 5)","category":"page"},{"location":"examples/basic/#Multiple-Timestamps-Example","page":"Basic Example","title":"Multiple Timestamps Example","text":"","category":"section"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"We can also calculate solar positions for a range of timestamps by creating an Observer object and collecting the time range into a vector.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"times = collect(DateTime(2019):Hour(1):DateTime(2020))\nposition_direct = solar_position(obs, times)\nfirst(DataFrame(position_direct), 5)","category":"page"},{"location":"algorithms/#algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Solar position algorithms available in SolarPosition.jl.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Algorithm Reference Accuracy Status\nPSA Blanco-Muriel et al. ±0.0083° ✅\nNOAA Global Monitoring Laboratory ±0.0167° ❌","category":"page"},{"location":"algorithms/#psa-algorithm","page":"Algorithms","title":"PSA","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The PSA (Plataforma Solar de Almería) algorithm is the default high-accuracy solar position algorithm.","category":"page"},{"location":"algorithms/#SolarPosition.Positioning.PSA","page":"Algorithms","title":"SolarPosition.Positioning.PSA","text":"struct PSA <: SolarPosition.Positioning.SolarAlgorithm\n\nPSA (Plataforma Solar de Almería) solar position algorithm.\n\nThis algorithm computes solar position with high accuracy using empirical coefficients. Two coefficient sets are available: 2001 (range 1999-2015) and 2020 (range 2020-2050).\n\nFields\n\ncoeffs::Int64: Coefficient set year (2001 or 2020)\n\nConstructor\n\nPSA(): Uses 2020 coefficients (default)\nPSA(2020): Uses 2020 coefficients (range 2020-2050, accuracy ±0.0083°)\nPSA(2001): Uses 2001 coefficients (range 1999-2015, accuracy ±0.0083°)\n\nReferences\n\n[1] M. Blanco, D. Alarcón, T. López, and M. Lara, \"Computing the Solar Vector,\"     Solar Energy, vol. 70, no. 5, 2001, doi:10.1016/S0038-092X(00)00156-0\n\n[2] M. Blanco, K. Milidonis, and A. Bonanos, \"Updating the PSA sun position algorithm,\"     Solar Energy, vol. 212, 2020, doi:10.1016/j.solener.2020.10.084\n\nExample\n\njulia> pos = solar_position(obs, dt, PSA())\nSolPos{Float64}(51.2154455981643, -8.618482096636027, 98.61848209663603)\n\njulia> pos_historical = solar_position(obs, dt, PSA(2001))\nSolPos{Float64}(51.21527503642826, -8.618604682115866, 98.61860468211586)\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#noaa-algorithm","page":"Algorithms","title":"NOAA","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The NOAA (National Oceanic and Atmospheric Administration) algorithm provides an alternative implementation.","category":"page"},{"location":"algorithms/#SolarPosition.Positioning.NOAA","page":"Algorithms","title":"SolarPosition.Positioning.NOAA","text":"struct NOAA <: SolarPosition.Positioning.SolarAlgorithm\n\nNOAA (National Oceanic and Atmospheric Administration) solar position algorithm.\n\nThis algorithm is based on NOAA's Solar Position Calculator implementation. Currently provides a stub implementation for testing purposes.\n\nAccuracy\n\nClaimed accuracy: ±0.0167° (when fully implemented)\n\nReferences\n\n[1] NOAA Global Monitoring Laboratory Solar Position Calculator     https://gml.noaa.gov/grad/solcalc/calcdetails.html\n\nStatus\n\n⚠️  Note: This is currently a stub implementation that returns fixed values. Full implementation is planned for future releases.\n\nExample\n\njulia> pos = solar_position(obs, dt, NOAA());  # Note: Currently returns stub values\n\njulia> typeof(pos)\nSolPos{Float64}\n\n\n\n\n\n","category":"type"}]
}
