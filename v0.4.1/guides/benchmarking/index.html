<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Benchmarking · SolarPosition.jl</title><meta name="title" content="Benchmarking · SolarPosition.jl"/><meta property="og:title" content="Benchmarking · SolarPosition.jl"/><meta property="twitter:title" content="Benchmarking · SolarPosition.jl"/><meta name="description" content="Documentation for SolarPosition.jl."/><meta property="og:description" content="Documentation for SolarPosition.jl."/><meta property="twitter:description" content="Documentation for SolarPosition.jl."/><meta property="og:url" content="https://juliaastro.org/SolarPosition/stable/guides/benchmarking/"/><meta property="twitter:url" content="https://juliaastro.org/SolarPosition/stable/guides/benchmarking/"/><link rel="canonical" href="https://juliaastro.org/SolarPosition/stable/guides/benchmarking/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SolarPosition.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Guides</span><ul><li><a class="tocitem" href="../getting-started/">Getting Started</a></li><li><a class="tocitem" href="../plotting/">Plotting with Makie.jl</a></li><li><a class="tocitem" href="../parallel/">Parallel Computing with OhMyThreads.jl</a></li><li><a class="tocitem" href="../modelingtoolkit/">Building models with ModelingToolkit.jl</a></li><li class="is-active"><a class="tocitem" href>Benchmarking</a><ul class="internal"><li><a class="tocitem" href="#Accuracy-Analysis"><span>Accuracy Analysis</span></a></li><li><a class="tocitem" href="#Performance-Benchmarks"><span>Performance Benchmarks</span></a></li><li><a class="tocitem" href="#Comparison-with-solposx-(Python)"><span>Comparison with solposx (Python)</span></a></li><li><a class="tocitem" href="#Accuracy-vs-Performance-Trade-off"><span>Accuracy vs Performance Trade-off</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li><li><a class="tocitem" href="../new-algorithm/">Adding a New Solar Position Algorithm</a></li></ul></li><li><a class="tocitem" href="../../reference/">API reference</a></li><li><a class="tocitem" href="../../positioning/">Solar Positioning</a></li><li><a class="tocitem" href="../../refraction/">Refraction Correction</a></li><li><a class="tocitem" href="../../utilities/">Utilities</a></li><li><a class="tocitem" href="../../deltat/">Delta T (ΔT)</a></li><li><a class="tocitem" href="../../literature/">Literature</a></li><li><a class="tocitem" href="../../contributing/">Contributing guidelines</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Guides</a></li><li class="is-active"><a href>Benchmarking</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Benchmarking</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaAstro/SolarPosition.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaAstro/SolarPosition.jl/blob/main/docs/src/guides/benchmarking.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="benchmarking"><a class="docs-heading-anchor" href="#benchmarking">Benchmarking</a><a id="benchmarking-1"></a><a class="docs-heading-anchor-permalink" href="#benchmarking" title="Permalink"></a></h1><p>This page provides comprehensive benchmarks of the solar position algorithms available in <code>SolarPosition.jl</code>, comparing their computational performance and accuracy. The <a href="../../positioning/#SolarPosition.Positioning.SPA">SPA</a> algorithm is used as the reference &quot;gold standard&quot; due to its high precision (±0.0003°).</p><pre><code class="language-julia hljs">using SolarPosition
using CairoMakie
using Dates
using DataFrames
using Statistics
using BenchmarkTools</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>For available solar position algorithms, see the <a href="../../reference/#SolarPosition.Positioning">Positioning Guide</a>.</p><h2 id="Accuracy-Analysis"><a class="docs-heading-anchor" href="#Accuracy-Analysis">Accuracy Analysis</a><a id="Accuracy-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Accuracy-Analysis" title="Permalink"></a></h2><p>To evaluate accuracy, we compare each algorithm against the gold standard SPA across a full year of hourly timestamps at various geographic locations.</p><pre><code class="language-julia hljs"># Test locations representing different latitudes
locations = [
    (name = &quot;Equator&quot;, obs = Observer(0.0, 0.0, 0.0)),
    (name = &quot;Mid-latitude (London)&quot;, obs = Observer(51.5074, -0.1278, 11.0)),
    (name = &quot;High-latitude (Oslo)&quot;, obs = Observer(59.9139, 10.7522, 23.0)),
    (name = &quot;Southern hemisphere (Sydney)&quot;, obs = Observer(-33.8688, 151.2093, 58.0)),
]

# Generate hourly timestamps for a full year
times = collect(DateTime(2024, 1, 1):Hour(1):DateTime(2024, 12, 31, 23))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><details class="admonition is-details" id="Accuracy-comparison-5ce135969daf7bfb"><summary class="admonition-header">Accuracy comparison<a class="admonition-anchor" href="#Accuracy-comparison-5ce135969daf7bfb" title="Permalink"></a></summary><div class="admonition-body"><pre><code class="language-julia hljs">using Statistics: quantile

&quot;&quot;&quot;
Compare algorithm accuracy against SPA reference.
Returns DataFrame with error statistics including percentiles.
&quot;&quot;&quot;
function compare_accuracy(obs::Observer, times::Vector{DateTime}, algo)
    # Get SPA reference positions
    spa_pos = solar_position(obs, times, SPA())

    # Get algorithm positions
    algo_pos = solar_position(obs, times, algo)

    # Calculate errors for all positions
    elev_errors = abs.(algo_pos.elevation .- spa_pos.elevation)
    azim_errors = abs.(algo_pos.azimuth .- spa_pos.azimuth)

    # Handle azimuth wraparound (0° and 360° are the same)
    azim_errors = min.(azim_errors, 360.0 .- azim_errors)

    return (
        elevation_mean = mean(elev_errors),
        elevation_p2_5 = quantile(elev_errors, 0.025),
        elevation_p97_5 = quantile(elev_errors, 0.975),
        elevation_max = maximum(elev_errors),
        azimuth_mean = mean(azim_errors),
        azimuth_p2_5 = quantile(azim_errors, 0.025),
        azimuth_p97_5 = quantile(azim_errors, 0.975),
        azimuth_max = maximum(azim_errors),
        n_samples = length(times),
    )
end

nothing # hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre></div></details><details class="admonition is-details" id="Data-collection-d42e2efdd2d8cd27"><summary class="admonition-header">Data collection<a class="admonition-anchor" href="#Data-collection-d42e2efdd2d8cd27" title="Permalink"></a></summary><div class="admonition-body"><pre><code class="language-julia hljs"># Algorithms to compare (excluding SPA which is the reference)
algorithms = [
    (&quot;PSA&quot;, PSA()),
    (&quot;NOAA&quot;, NOAA()),
    (&quot;Walraven&quot;, Walraven()),
    (&quot;USNO&quot;, USNO()),
]

# Collect accuracy data
accuracy_results = DataFrame(
    Algorithm = String[],
    Location = String[],
    Elevation_Mean_Error = Float64[],
    Elevation_P2_5 = Float64[],
    Elevation_P97_5 = Float64[],
    Elevation_Max_Error = Float64[],
    Azimuth_Mean_Error = Float64[],
    Azimuth_P2_5 = Float64[],
    Azimuth_P97_5 = Float64[],
    Azimuth_Max_Error = Float64[],
)

for (algo_name, algo) in algorithms
    for loc in locations
        stats = compare_accuracy(loc.obs, times, algo)
        push!(accuracy_results, (
            Algorithm = algo_name,
            Location = loc.name,
            Elevation_Mean_Error = stats.elevation_mean,
            Elevation_P2_5 = stats.elevation_p2_5,
            Elevation_P97_5 = stats.elevation_p97_5,
            Elevation_Max_Error = stats.elevation_max,
            Azimuth_Mean_Error = stats.azimuth_mean,
            Azimuth_P2_5 = stats.azimuth_p2_5,
            Azimuth_P97_5 = stats.azimuth_p97_5,
            Azimuth_Max_Error = stats.azimuth_max,
        ))
    end
end

accuracy_results</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre></div></details><p>The following plots show the mean error with 95% confidence intervals (2.5th to 97.5th percentile) for each algorithm compared to SPA.</p><details class="admonition is-details" id="Visualization-b46a993d8ec73a4d"><summary class="admonition-header">Visualization<a class="admonition-anchor" href="#Visualization-b46a993d8ec73a4d" title="Permalink"></a></summary><div class="admonition-body"><pre><code class="language-julia hljs"># Aggregate results by algorithm (mean across all locations)
algo_stats = combine(
    groupby(accuracy_results, :Algorithm),
    :Elevation_Mean_Error =&gt; mean =&gt; :Elev_Mean,
    :Elevation_P2_5 =&gt; mean =&gt; :Elev_P2_5,
    :Elevation_P97_5 =&gt; mean =&gt; :Elev_P97_5,
    :Azimuth_Mean_Error =&gt; mean =&gt; :Azim_Mean,
    :Azimuth_P2_5 =&gt; mean =&gt; :Azim_P2_5,
    :Azimuth_P97_5 =&gt; mean =&gt; :Azim_P97_5,
)

# Sort by algorithm order
algo_order = [&quot;PSA&quot;, &quot;NOAA&quot;, &quot;Walraven&quot;, &quot;USNO&quot;]
algo_stats = algo_stats[sortperm([findfirst(==(algo), algo_order) for algo in algo_stats.Algorithm]), :]

fig = Figure(size = (900, 400), backgroundcolor = :transparent, fontsize = 12, textcolor = &quot;#f5ab35&quot;)

# Elevation error plot with error bars
ax1 = Axis(fig[1, 1],
    title = &quot;Elevation Error vs SPA (95% CI)&quot;,
    xlabel = &quot;Algorithm&quot;,
    ylabel = &quot;Error (degrees)&quot;,
    xticks = (1:4, algo_stats.Algorithm),
    backgroundcolor = :transparent,
)

# Error bars showing 95% interval
errorbars!(ax1, 1:4, algo_stats.Elev_Mean,
    algo_stats.Elev_Mean .- algo_stats.Elev_P2_5,
    algo_stats.Elev_P97_5 .- algo_stats.Elev_Mean,
    color = :steelblue, linewidth = 2, whiskerwidth = 10)
scatter!(ax1, 1:4, algo_stats.Elev_Mean, color = :steelblue, markersize = 12)

# Azimuth error plot with error bars
ax2 = Axis(fig[1, 2],
    title = &quot;Azimuth Error vs SPA (95% CI)&quot;,
    xlabel = &quot;Algorithm&quot;,
    ylabel = &quot;Error (degrees)&quot;,
    xticks = (1:4, algo_stats.Algorithm),
    backgroundcolor = :transparent,
)

errorbars!(ax2, 1:4, algo_stats.Azim_Mean,
    algo_stats.Azim_Mean .- algo_stats.Azim_P2_5,
    algo_stats.Azim_P97_5 .- algo_stats.Azim_Mean,
    color = :coral, linewidth = 2, whiskerwidth = 10)
scatter!(ax2, 1:4, algo_stats.Azim_Mean, color = :coral, markersize = 12)

nothing # hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre></div></details><pre><code class="language-julia hljs">fig # hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><h3 id="PSA-Error-Over-Time"><a class="docs-heading-anchor" href="#PSA-Error-Over-Time">PSA Error Over Time</a><a id="PSA-Error-Over-Time-1"></a><a class="docs-heading-anchor-permalink" href="#PSA-Error-Over-Time" title="Permalink"></a></h3><p>To better understand how errors vary throughout the year, we compare the PSA algorithm against SPA at hourly resolution for a full year at a single location.</p><pre><code class="language-julia hljs"># Generate hourly timestamps for a full year (reduces memory usage vs minute resolution)
hourly_times = collect(DateTime(2024, 1, 1):Hour(1):DateTime(2024, 12, 31, 23))
obs_london = Observer(51.5074, -0.1278, 11.0)

# Calculate positions
spa_positions = solar_position(obs_london, hourly_times, SPA())
psa_positions = solar_position(obs_london, hourly_times, PSA())

# Calculate errors
elev_errors = psa_positions.elevation .- spa_positions.elevation
azim_errors = psa_positions.azimuth .- spa_positions.azimuth

# Handle azimuth wraparound
azim_errors = [abs(e) &gt; 180 ? e - sign(e) * 360 : e for e in azim_errors]

println(&quot;PSA vs SPA at hourly resolution ($(length(hourly_times)) samples):&quot;)
println(&quot;  Elevation: mean=$(round(mean(abs.(elev_errors)), digits=6))°, max=$(round(maximum(abs.(elev_errors)), digits=4))°&quot;)
println(&quot;  Azimuth: mean=$(round(mean(abs.(azim_errors)), digits=6))°, max=$(round(maximum(abs.(azim_errors)), digits=4))°&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><details class="admonition is-details" id="Visualization-a4e34d2e11804ae4"><summary class="admonition-header">Visualization<a class="admonition-anchor" href="#Visualization-a4e34d2e11804ae4" title="Permalink"></a></summary><div class="admonition-body"><pre><code class="language-julia hljs">fig_err = Figure(size = (900, 500), backgroundcolor = :transparent, fontsize = 12, textcolor = &quot;#f5ab35&quot;)

# Convert to day of year for x-axis
day_of_year = [Dates.dayofyear(t) for t in hourly_times]

ax1 = Axis(fig_err[1, 1],
    title = &quot;PSA Elevation Error vs SPA (2024, London)&quot;,
    xlabel = &quot;Day of Year&quot;,
    ylabel = &quot;Error (degrees)&quot;,
    backgroundcolor = :transparent,
)
scatter!(ax1, day_of_year, elev_errors, markersize = 1.5, color = (:steelblue, 0.5))
hlines!(ax1, [0.0], color = :gray, linestyle = :dash)

ax2 = Axis(fig_err[2, 1],
    title = &quot;PSA Azimuth Error vs SPA (2024, London)&quot;,
    xlabel = &quot;Day of Year&quot;,
    ylabel = &quot;Error (degrees)&quot;,
    backgroundcolor = :transparent,
)
scatter!(ax2, day_of_year, azim_errors, markersize = 1.5, color = (:coral, 0.5))
hlines!(ax2, [0.0], color = :gray, linestyle = :dash)

nothing # hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre></div></details><pre><code class="language-julia hljs">fig_err # hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><h3 id="Error-Distribution-by-Location"><a class="docs-heading-anchor" href="#Error-Distribution-by-Location">Error Distribution by Location</a><a id="Error-Distribution-by-Location-1"></a><a class="docs-heading-anchor-permalink" href="#Error-Distribution-by-Location" title="Permalink"></a></h3><details class="admonition is-details" id="Visualization-142efbfa2a199f2c"><summary class="admonition-header">Visualization<a class="admonition-anchor" href="#Visualization-142efbfa2a199f2c" title="Permalink"></a></summary><div class="admonition-body"><pre><code class="language-julia hljs">fig2 = Figure(size = (900, 500), backgroundcolor = :transparent, fontsize = 11, textcolor = &quot;#f5ab35&quot;)

for (i, loc) in enumerate(locations)
    row = (i - 1) ÷ 2 + 1
    col = (i - 1) % 2 + 1

    ax = Axis(fig2[row, col],
        title = loc.name,
        xlabel = &quot;Algorithm&quot;,
        ylabel = &quot;Mean Elevation Error (°)&quot;,
        xticks = (1:4, [a[1] for a in algorithms]),
        backgroundcolor = :transparent,
    )

    loc_data = filter(r -&gt; r.Location == loc.name, accuracy_results)
    barplot!(ax, 1:4, loc_data.Elevation_Mean_Error, color = :teal)
end

Label(fig2[0, :], &quot;Elevation Error by Location&quot;, fontsize = 14, font = :bold)

nothing # hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre></div></details><pre><code class="language-julia hljs">fig2 # hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>As we can see the error distribution is relatively consistent across different geographic locations, with PSA consistently providing the lowest mean error compared to SPA.</p><h2 id="Performance-Benchmarks"><a class="docs-heading-anchor" href="#Performance-Benchmarks">Performance Benchmarks</a><a id="Performance-Benchmarks-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Benchmarks" title="Permalink"></a></h2><p>We benchmark the computational performance of each algorithm across different input sizes, from single timestamp calculations to bulk operations with 10,000 timestamps.</p><details class="admonition is-details" id="Single-benchmark-49a16178c1b1537a"><summary class="admonition-header">Single benchmark<a class="admonition-anchor" href="#Single-benchmark-49a16178c1b1537a" title="Permalink"></a></summary><div class="admonition-body"><pre><code class="language-julia hljs"># Single position benchmarks
obs = Observer(51.5074, -0.1278, 11.0)  # London
dt = DateTime(2024, 6, 21, 12, 0, 0)

single_benchmarks = DataFrame(
    Algorithm = String[],
    Time_ns = Float64[],
    Allocations = Int[],
)

for (name, algo) in [(&quot;PSA&quot;, PSA()), (&quot;NOAA&quot;, NOAA()), (&quot;Walraven&quot;, Walraven()),
                      (&quot;USNO&quot;, USNO()), (&quot;SPA&quot;, SPA())]
    b = @benchmark solar_position($obs, $dt, $algo) samples=100 evals=10
    push!(single_benchmarks, (
        Algorithm = name,
        Time_ns = median(b.times),
        Allocations = b.allocs,
    ))
end

# Add relative timing
single_benchmarks.Time_μs = single_benchmarks.Time_ns ./ 1000
spa_time = filter(row -&gt; row.Algorithm == &quot;SPA&quot;, single_benchmarks).Time_ns[1]
single_benchmarks.Relative_to_SPA = single_benchmarks.Time_ns ./ spa_time

single_benchmarks[:, [:Algorithm, :Time_μs, :Allocations, :Relative_to_SPA]]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre></div></details><details class="admonition is-details" id="Vector-benchmark-4cc07a765c809457"><summary class="admonition-header">Vector benchmark<a class="admonition-anchor" href="#Vector-benchmark-4cc07a765c809457" title="Permalink"></a></summary><div class="admonition-body"><pre><code class="language-julia hljs"># Vector benchmarks for different sizes
sizes = [100, 1_000, 10_000]

vector_benchmarks = DataFrame(
    Algorithm = String[],
    N = Int[],
    Time_ms = Float64[],
    Throughput = Float64[],  # positions per second
)

for n in sizes
    times_vec = collect(DateTime(2024, 1, 1):Hour(1):(DateTime(2024, 1, 1) + Hour(n-1)))

    for (name, algo) in [(&quot;PSA&quot;, PSA()), (&quot;NOAA&quot;, NOAA()), (&quot;Walraven&quot;, Walraven()),
                          (&quot;USNO&quot;, USNO()), (&quot;SPA&quot;, SPA())]
        b = @benchmark solar_position($obs, $times_vec, $algo) samples=10 evals=1
        time_ms = median(b.times) / 1e6
        push!(vector_benchmarks, (
            Algorithm = name,
            N = n,
            Time_ms = time_ms,
            Throughput = n / (time_ms / 1000),
        ))
    end
end

# Pivot for display
vector_pivot = unstack(vector_benchmarks, :Algorithm, :N, :Time_ms)
vector_pivot</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre></div></details><details class="admonition is-details" id="Visualization-e1c50fcc96f02448"><summary class="admonition-header">Visualization<a class="admonition-anchor" href="#Visualization-e1c50fcc96f02448" title="Permalink"></a></summary><div class="admonition-body"><pre><code class="language-julia hljs">fig3 = Figure(size = (900, 400), backgroundcolor = :transparent, fontsize = 12, textcolor = &quot;#f5ab35&quot;)

# Scaling plot (log-log)
ax1 = Axis(fig3[1, 1],
    title = &quot;Computation Time vs Input Size&quot;,
    xlabel = &quot;Number of Timestamps&quot;,
    ylabel = &quot;Time (ms)&quot;,
    xscale = log10,
    yscale = log10,
    backgroundcolor = :transparent,
)

colors = [:blue, :orange, :green, :purple, :red]
algo_names = [&quot;PSA&quot;, &quot;NOAA&quot;, &quot;Walraven&quot;, &quot;USNO&quot;, &quot;SPA&quot;]

for (i, algo) in enumerate(algo_names)
    data = filter(r -&gt; r.Algorithm == algo, vector_benchmarks)
    lines!(ax1, data.N, data.Time_ms, label = algo, color = colors[i], linewidth = 2)
    scatter!(ax1, data.N, data.Time_ms, color = colors[i], markersize = 8)
end
axislegend(ax1, position = :rb, framevisible = false, labelsize = 10)

# Throughput plot
ax2 = Axis(fig3[1, 2],
    title = &quot;Throughput at N=10,000&quot;,
    xlabel = &quot;Algorithm&quot;,
    ylabel = &quot;Positions per Second&quot;,
    xticks = (1:5, algo_names),
    backgroundcolor = :transparent,
)

throughput_10k = filter(r -&gt; r.N == 10_000, vector_benchmarks)
barplot!(ax2, 1:5, throughput_10k.Throughput ./ 1e6, color = colors)
ax2.ylabel = &quot;Million Positions / Second&quot;

nothing # hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre></div></details><pre><code class="language-julia hljs">fig3 # hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><h2 id="Comparison-with-solposx-(Python)"><a class="docs-heading-anchor" href="#Comparison-with-solposx-(Python)">Comparison with solposx (Python)</a><a id="Comparison-with-solposx-(Python)-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison-with-solposx-(Python)" title="Permalink"></a></h2><p>The <a href="https://github.com/assessingsolar/solposx">solposx</a> package is a Python library that implements the same solar position algorithms. This section compares the performance of SolarPosition.jl against solposx to demonstrate the benefits of using Julia.</p><div class="admonition is-info" id="Benchmarking-Methodology-b3abe99d1106274a"><header class="admonition-header">Benchmarking Methodology<a class="admonition-anchor" href="#Benchmarking-Methodology-b3abe99d1106274a" title="Permalink"></a></header><div class="admonition-body"><p>The benchmarks below use <a href="https://github.com/JuliaPy/PythonCall.jl">PythonCall.jl</a> to call <code>solposx</code> from within Julia. We have also benchmarked <code>solposx</code> directly in a pure Python environment (without <code>PythonCall.jl</code> overhead) and found no significant difference in the results.</p></div></div><h3 id="Setup"><a class="docs-heading-anchor" href="#Setup">Setup</a><a id="Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Setup" title="Permalink"></a></h3><p>First, we install and import solposx using <a href="https://github.com/JuliaPy/PythonCall.jl">PythonCall.jl</a> and <a href="https://github.com/JuliaPy/CondaPkg.jl">CondaPkg.jl</a>:</p><pre><code class="language-julia hljs">using CondaPkg
CondaPkg.add_pip(&quot;solposx&quot;)
CondaPkg.add_pip(&quot;pandas&quot;)

using PythonCall

# Import Python modules
sp = pyimport(&quot;solposx.solarposition&quot;)
pd = pyimport(&quot;pandas&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><h3 id="Configuration"><a class="docs-heading-anchor" href="#Configuration">Configuration</a><a id="Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Configuration" title="Permalink"></a></h3><p>For fair comparison, we use the same test conditions for both libraries:</p><ul><li><strong>Observer</strong>: London (51.5074°N, 0.1278°W, 11m elevation)</li><li><strong>Timestamps</strong>: Hourly data from January 1, 2024</li><li><strong>Algorithms</strong>: PSA, NOAA, Walraven, USNO, SPA</li></ul><pre><code class="language-julia hljs">function create_pandas_times(n::Int)
    pd.date_range(start=&quot;2024-01-01 00:00:00&quot;, periods=n, freq=&quot;h&quot;, tz=&quot;UTC&quot;)
end

solposx_algorithms = Dict(
    &quot;PSA&quot; =&gt; (sp.psa, (coefficients = 2020,)),
    &quot;NOAA&quot; =&gt; (sp.noaa, NamedTuple()),
    &quot;Walraven&quot; =&gt; (sp.walraven, NamedTuple()),
    &quot;USNO&quot; =&gt; (sp.usno, NamedTuple()),
    &quot;SPA&quot; =&gt; (sp.spa, NamedTuple()),
)

lat, lon = 51.5074, -0.1278</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><h3 id="Running-the-Benchmarks"><a class="docs-heading-anchor" href="#Running-the-Benchmarks">Running the Benchmarks</a><a id="Running-the-Benchmarks-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-Benchmarks" title="Permalink"></a></h3><p>We benchmark both libraries across different input sizes:</p><details class="admonition is-details" id="Benchmark-code-707bd8021b1871da"><summary class="admonition-header">Benchmark code<a class="admonition-anchor" href="#Benchmark-code-707bd8021b1871da" title="Permalink"></a></summary><div class="admonition-body"><pre><code class="language-julia hljs"># Benchmark sizes
sizes = [100, 1_000, 10_000]

# Results storage
comparison_results = DataFrame(
    Algorithm = String[],
    N = Int[],
    Julia_ms = Float64[],
    Python_ms = Float64[],
    Speedup = Float64[],
)

for n in sizes
    # Create time vectors
    julia_times_vec = collect(DateTime(2024, 1, 1):Hour(1):(DateTime(2024, 1, 1) + Hour(n-1)))
    py_times_idx = create_pandas_times(n)

    for (algo_name, algo) in [(&quot;PSA&quot;, PSA()), (&quot;NOAA&quot;, NOAA()), (&quot;Walraven&quot;, Walraven()),
                               (&quot;USNO&quot;, USNO()), (&quot;SPA&quot;, SPA())]
        # Julia benchmark
        julia_bench = @benchmark solar_position($obs, $julia_times_vec, $algo) samples=5 evals=1
        julia_time_ms = median(julia_bench.times) / 1e6

        # Python benchmark
        py_func, py_kwargs = solposx_algorithms[algo_name]

        # Benchmark Python function using BenchmarkTools
        if isempty(py_kwargs)
            py_bench = @benchmark $py_func($py_times_idx, $lat, $lon) samples=5 evals=1
        else
            py_bench = @benchmark $py_func($py_times_idx, $lat, $lon; $py_kwargs...) samples=5 evals=1
        end
        python_time_ms = median(py_bench.times) / 1e6

        speedup = python_time_ms / julia_time_ms

        push!(comparison_results, (
            Algorithm = algo_name,
            N = n,
            Julia_ms = round(julia_time_ms, digits=3),
            Python_ms = round(python_time_ms, digits=3),
            Speedup = round(speedup, digits=1),
        ))
    end
end

comparison_results</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre></div></details><details class="admonition is-details" id="Visualization-c27df187a7950947"><summary class="admonition-header">Visualization<a class="admonition-anchor" href="#Visualization-c27df187a7950947" title="Permalink"></a></summary><div class="admonition-body"><pre><code class="language-julia hljs">fig5 = Figure(size = (600, 750), backgroundcolor = :transparent, fontsize = 12, textcolor = &quot;#f5ab35&quot;)

# Group by algorithm for plotting
algo_names = [&quot;PSA&quot;, &quot;NOAA&quot;, &quot;Walraven&quot;, &quot;USNO&quot;, &quot;SPA&quot;]
colors_julia = [:blue, :green, :purple, :orange, :red]

ax1 = Axis(fig5[1, 1],
    title = &quot;Computation Time: Julia vs Python&quot;,
    xlabel = &quot;Number of Timestamps&quot;,
    ylabel = &quot;Time (ms)&quot;,
    xscale = log10,
    yscale = log10,
    backgroundcolor = :transparent,
)

# Store line objects for legends
julia_lines = []
python_lines = []

for (i, algo) in enumerate(algo_names)
    data = filter(r -&gt; r.Algorithm == algo, comparison_results)

    # Julia times (solid lines)
    l1 = lines!(ax1, data.N, data.Julia_ms,
        color = colors_julia[i],
        linewidth = 2)
    scatter!(ax1, data.N, data.Julia_ms, color = colors_julia[i], markersize = 6)
    push!(julia_lines, l1)

    # Python times (dashed lines)
    l2 = lines!(ax1, data.N, data.Python_ms,
        color = colors_julia[i],
        linewidth = 2,
        linestyle = :dash)
    scatter!(ax1, data.N, data.Python_ms, color = colors_julia[i], markersize = 6,
        marker = :utriangle)
    push!(python_lines, l2)
end

# Algorithm legend (colors)
leg1 = Legend(fig5[1, 2][1, 1], julia_lines, algo_names, &quot;Algorithm&quot;,
    framevisible = true, backgroundcolor = :transparent, labelsize = 10, titlesize = 11)

# Line style legend (solid vs dashed)
style_lines = [LineElement(color = :gray, linewidth = 2, linestyle = :solid),
               LineElement(color = :gray, linewidth = 2, linestyle = :dash)]
leg2 = Legend(fig5[1, 2][2, 1], style_lines, [&quot;Julia&quot;, &quot;Python&quot;], &quot;Library&quot;,
    framevisible = true, backgroundcolor = :transparent, labelsize = 10, titlesize = 11)

# Speedup bar chart
ax2 = Axis(fig5[2, 1:2],
    title = &quot;Julia vs Python at N=1,000&quot;,
    xlabel = &quot;Algorithm&quot;,
    ylabel = &quot;Speedup Factor (×)&quot;,
    xticks = (1:5, algo_names),
    backgroundcolor = :transparent,
)

speedup_1k = filter(r -&gt; r.N == 1_000, comparison_results)
barplot!(ax2, 1:5, speedup_1k.Speedup, color = colors_julia)
hlines!(ax2, [1.0], color = :gray, linestyle = :dash)

nothing # hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre></div></details><pre><code class="language-julia hljs">fig5 # hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><h2 id="Accuracy-vs-Performance-Trade-off"><a class="docs-heading-anchor" href="#Accuracy-vs-Performance-Trade-off">Accuracy vs Performance Trade-off</a><a id="Accuracy-vs-Performance-Trade-off-1"></a><a class="docs-heading-anchor-permalink" href="#Accuracy-vs-Performance-Trade-off" title="Permalink"></a></h2><p>When selecting a solar position algorithm, there is often a trade-off between accuracy and computational performance. The following Pareto plot visualizes this trade-off by plotting mean elevation error against computation time at N=1,000 timestamps, comparing both Julia and Python implementations.</p><details class="admonition is-details" id="Pareto-Analysis-f472822c11daa3cf"><summary class="admonition-header">Pareto Analysis<a class="admonition-anchor" href="#Pareto-Analysis-f472822c11daa3cf" title="Permalink"></a></summary><div class="admonition-body"><pre><code class="language-julia hljs"># Combine accuracy and performance data for Pareto analysis at N=1000
# Get mean elevation error across all locations for each algorithm
pareto_data = combine(
    groupby(accuracy_results, :Algorithm),
    :Elevation_Mean_Error =&gt; mean =&gt; :Mean_Error
)

# Add SPA as reference (error = 0)
push!(pareto_data, (Algorithm = &quot;SPA&quot;, Mean_Error = 0.0))

# Get Julia timing at N=1000
julia_times_1k = filter(r -&gt; r.N == 1_000, comparison_results)
pareto_julia = leftjoin(pareto_data,
    select(julia_times_1k, :Algorithm, :Julia_ms),
    on = :Algorithm)
pareto_julia.Library = fill(&quot;Julia&quot;, nrow(pareto_julia))

# Get Python timing at N=1000
pareto_python = leftjoin(pareto_data,
    select(julia_times_1k, :Algorithm, :Python_ms),
    on = :Algorithm)
rename!(pareto_python, :Python_ms =&gt; :Julia_ms)  # Reuse column name for convenience
pareto_python.Library = fill(&quot;Python&quot;, nrow(pareto_python))

# Combine both
pareto_combined = vcat(pareto_julia, pareto_python)
rename!(pareto_combined, :Julia_ms =&gt; :Time_ms)

# Sort by error then time
sort!(pareto_combined, [:Mean_Error, :Time_ms])

pareto_combined</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre></div></details><details class="admonition is-details" id="Visualization-fdc14a6b1911cece"><summary class="admonition-header">Visualization<a class="admonition-anchor" href="#Visualization-fdc14a6b1911cece" title="Permalink"></a></summary><div class="admonition-body"><pre><code class="language-julia hljs">fig_pareto = Figure(size = (700, 550), backgroundcolor = :transparent, fontsize = 12, textcolor = &quot;#f5ab35&quot;)

ax = Axis(fig_pareto[1, 1],
    title = &quot;Algorithm Selection: Accuracy vs Performance (N=1,000)&quot;,
    xlabel = &quot;Computation Time (ms)&quot;,
    ylabel = &quot;Mean Elevation Error vs SPA (°)&quot;,
    backgroundcolor = :transparent,
)

# Color scheme for algorithms
colors_pareto = Dict(
    &quot;PSA&quot; =&gt; :steelblue,
    &quot;NOAA&quot; =&gt; :orange,
    &quot;Walraven&quot; =&gt; :green,
    &quot;USNO&quot; =&gt; :purple,
    &quot;SPA&quot; =&gt; :red
)

# Marker scheme for library
markers_lib = Dict(
    &quot;Julia&quot; =&gt; :circle,
    &quot;Python&quot; =&gt; :utriangle
)

# Plot points
julia_points = []
python_points = []

for row in eachrow(pareto_combined)
    marker = markers_lib[row.Library]
    color = colors_pareto[row.Algorithm]

    s = scatter!(ax, [row.Time_ms], [row.Mean_Error],
            color = color,
            marker = marker,
            markersize = 15)

    if row.Library == &quot;Julia&quot;
        push!(julia_points, s)
    else
        push!(python_points, s)
    end
end

# Add algorithm labels for Julia implementations
for row in eachrow(filter(r -&gt; r.Library == &quot;Julia&quot;, pareto_combined))
    text!(ax, row.Time_ms, row.Mean_Error,
          text = &quot;  &quot; * row.Algorithm,
          align = (:left, :center),
          fontsize = 10)
end

# Add algorithm labels for Python implementations
for row in eachrow(filter(r -&gt; r.Library == &quot;Python&quot;, pareto_combined))
    text!(ax, row.Time_ms, row.Mean_Error,
          text = &quot;  &quot; * row.Algorithm,
          align = (:left, :center),
          fontsize = 9,
          color = (:gray40, 0.8))
end

# Connect Julia points to show the trade-off curve
julia_data = sort(filter(r -&gt; r.Library == &quot;Julia&quot;, pareto_combined), :Time_ms)
lines!(ax, julia_data.Time_ms, julia_data.Mean_Error,
       color = (:steelblue, 0.3), linestyle = :dash, linewidth = 1.5, label = &quot;Julia Frontier&quot;)

# Connect Python points
python_data = sort(filter(r -&gt; r.Library == &quot;Python&quot;, pareto_combined), :Time_ms)
lines!(ax, python_data.Time_ms, python_data.Mean_Error,
       color = (:coral, 0.3), linestyle = :dot, linewidth = 1.5, label = &quot;Python Frontier&quot;)

# Set y-axis limits for better discrimination
ylims!(ax, nothing, 0.005)

# Add guidelines for accuracy levels
hlines!(ax, [0.001, 0.002], color = (:gray, 0.2), linestyle = :dot, linewidth = 1)

# Create legend for library types
library_elements = [
    MarkerElement(marker = :circle, color = :gray, markersize = 12),
    MarkerElement(marker = :utriangle, color = :gray, markersize = 12)
]
Legend(fig_pareto[1, 2], library_elements, [&quot;Julia&quot;, &quot;Python&quot;], &quot;Library&quot;,
       framevisible = true, backgroundcolor = :transparent, labelsize = 10)

nothing # hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre></div></details><pre><code class="language-julia hljs">fig_pareto # hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>The benchmarks demonstrate that SolarPosition.jl offers significant performance advantages over the solposx Python library across all tested algorithms and input sizes.</p><div class="admonition is-info" id="Multi-threading-5b4e606c8e6215a3"><header class="admonition-header">Multi-threading<a class="admonition-anchor" href="#Multi-threading-5b4e606c8e6215a3" title="Permalink"></a></header><div class="admonition-body"><p><code>SolarPosition.jl</code> can leverage Julia&#39;s native multi-threading capabilities (see <a href="../parallel/#parallel-computing">Parallel Computing</a>) for further performance improvements on large datasets. The benchmarks above were conducted using a single thread for fair comparison with <code>solposx</code>, but enabling multi-threading can yield even greater speedups in practical applications.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../modelingtoolkit/">« Building models with ModelingToolkit.jl</a><a class="docs-footer-nextpage" href="../new-algorithm/">Adding a New Solar Position Algorithm »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 17 January 2026 02:20">Saturday 17 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
